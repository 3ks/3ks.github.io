{"pages":[{"title":"","text":"找不到这个奇怪的链接！点击返回首页","link":"/404.html"},{"title":"欢迎访问","text":"您好，欢迎访问我的博客。 博客说明一个没什么技术含量的博客，内容大都不成体系，主要是一些自己的学习笔记，不对的地方请多多指教。 静态博客基于 Hexo，使用主题 icarus CDN除 html 文件外，几乎所有的静态文件都通过 CDN 加速。虽然服务器在美国，但访问速度还是不错 GitHub Action基于 GitHub Action 实现 CI/CD，分别部署到了 https://3ks.dev 和 https://3ks.github.io 一个由自己的服务器提供服务，一个由 GitHub Page 托管，其中一个挂掉，也可以访问另一个，两者内容完全一致 我是官余棚，朋友们一般叫我官二、官二代，来自重庆，农民的儿子，一个吃瓜群众 重庆师范大学计算机科学与技术 2019 届毕业生。 职业21 世纪的农民——码农，目前正在寻找上海地区 Golang 或云原生方向的工作。 标签学以致用、强迫症、爱折腾、有思想、爱自由、死肥宅、内向、友善、杠精、专一 爱好宅、肉、美剧、4K/蓝光电影、3C 产品、可口可乐、英雄联盟 开源贡献大部分都是一些没什么技术含量的贡献，但我不认为自己所做的事情没有意义，我把这看作是一个学习、积累的过程 开源组织侥幸混进了一些开源组织，请访问 https://github.com/3ks 查看。 Golang 基础 gobyexample-cn/gobyexample polaris1119/The-Golang-Standard-Library-by-Example unknwon/the-way-to-go_ZH_CN Golang 应用 google/go-github gin-gonic/website go-gorm/gorm.io facebookincubator/ent Golang 及云原生 servicemesher/istio-handbook servicemesher/istio-official-translation kubernetes/website istio/istio.io 计算机基础 CyC2018/CS-Notes 前端 ppoffice/hexo-theme-icarus 火箭 🚀 chrislgarry/Apollo-11 r-spacex/SpaceX-API 为什么是 3ks我的 GitHub ID 是 3ks，所以就申请了 3ks.dev 域名 为什么是 3ks 呢？很简单，因为短，对于 ID 这种东西，个人认为越短越好（深受 QQ 号荼毒） 并且 3ks 的中文发音与 tks 相同，意为谢谢。同时，谢谢 也是我的口头禅 别问我为什么不用 tks，我是不会告诉你已经被别人占用了的😒 自我评价一个资质平平的普通人 在领略全球顶级的开发者的风采、见识十几岁天才的资质后，我认识到自己：只是一个凭着爱好碰巧进入了这个行业的普通人而已 虽然世界是由天才来改变的，但天才毕竟只是极少数，普通人也有普通人要做的事，普通人也能为世界更美好贡献一份力量 联系方式 邮箱：1@linux.com GitHub：https://github/3ks","link":"/about/index.html"}],"posts":[{"title":"Linux 清理缓存","text":"万物皆文件，清空文件即清理缓存，执行下面的命令即可： 1$ sync &amp;&amp; echo 1 &gt; /proc/sys/vm/drop_caches &amp;&amp; echo 2 &gt; /proc/sys/vm/drop_caches &amp;&amp; echo 3 &gt; /proc/sys/vm/drop_caches 参考链接linux 内存清理/释放命令","link":"/2020/07/14/clean-cache/"},{"title":"Hello World","text":"欢迎 来到 Hexo! 普通文本Hello World 图片 引用 一个肮脏的国家，如果人人讲规则而不是空谈道德，最终会变成一个有人味儿的正常国家，道德自然会逐渐回归；反之，一个干净的国家，如果人人都不讲规则却大谈道德、谈高尚，天天没事儿就谈道德规范，人人大公无私，最终这个国家会堕落成为一个伪君子遍布的肮脏国家。——沙雕网友 表格 日期 天气 气温 湿度 2020-07-13 晴 33℃ 95% 2020-07-14 阴 28℃ 97% 2020-07-15 小雨 25℃ 99% 纯文本块123Hello WorldWelcome! shell 脚本片段1$ echo \"hello world\" GO 代码main.go查看源文件1234567package mainimport \"fmt\"func main() { fmt.Println(\"hello world\")} JSON 片段1234{\"title\": \"hello world\",\"themes\": \"icarus\"} YAML 片段config.yml12\"title\": \"hello world\"\"themes\": \"icarus\" 一级标题普通文本 二级标题普通文本 三级标题普通文本 四级标题普通文本","link":"/2020/07/14/hello-world/"},{"title":"CentOS 分配和禁用 swap 空间","text":"云服务的内存不够，也没有自动分配 swap 空间，导致 mysql 服务器无法启动。 此时我们可以自己分配 swap 空间作为缓存，个人感觉 swap 类似于 windows 里的虚拟内存。 分配并启用 swap获取硬盘设备路径1$ df -h 分配空间4G1$ sudo dd if=/dev/vda1 of=/swapfile count=4096 bs=1MiB DO 文档里面的 sudo fallocate -l 4G /swapfile 是错误的，评论区出人才！ 权限设置12$ sudo chmod 600 /swapfile$ sudo mkswap /swapfile 制作 swap 系统，如果成功会有一个类似下面的提示： 12Setting up swapspace version 1, size = 4194300 KiBno label, UUID=b99230bb-21af-47bc-8c37-de41129c39bf 启动 swap1$ sudo swapon /swapfile 查看结果1free -m 检查 swap 是否已经在运行、有容量了。 开机自动挂载在文件 /etc/sysctl.conf 末尾追加内容、并保存 /etc/sysctl.conf1/swapfile swap swap sw 0 0 禁用系统默认的 swap 分区某些场景下，不能使用 swap 分区，此时则应该禁用 swap 分区： 取消挂载编辑 /etc/fstab 文件，取消 swap 分区的挂载： /etc/fstab123456789# /etc/fstab# Created by anaconda on Sat Feb 29 05:30:30 2020## Accessible filesystems, by reference, are maintained under '/dev/disk'# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info#/dev/mapper/centos-root / xfs defaults 0 0UUID=666d6259-55da-4501-91fb-40b2c0b16ca2 /boot xfs defaults 0 0/dev/mapper/centos-swap swap swap defaults 0 0 swap 文件系统那一行对应的路径就是目前挂载的 swap 分区。 我们将这一行删掉，或者注释掉，保存退出。 下次系统启动时就不会自动挂载该 swap 分区。 如果不想重启系统，根据 swap 分区的路径，执行下面的命令即可立即禁用 swap 分区。 1$ swapoff /dev/mapper/centos-swap 释放分区todo 参考链接How To Add Swap on CentOS 7 CentOS 7 关闭 swap 分区","link":"/2020/07/14/malloc-swap/"},{"title":"如何为你的 GitHub 项目添加 badge","text":"我们在很多开源项目的 README 都能看到大量的徽章（badge），这些徽章大都挺漂亮的，最重要的是，通过这些徽章，我们可以快速的获取项目的状态信息，例如：开源协议、版本、单元测试覆盖率等。 那我们应该如何为自己的项目加上一些徽章呢？ markdown 与图片markdown 插入图片我们都知道项目的 README 是一个 markdown 文件，在 markdown 内可以这样插入一张图片 1![](https://cdn.sguan.top/markdown/20200721141223.png) 其效果类似于这样： markdown 插入图片链接此外，如果我们想在点击图片后，跳转到某个页面，可以这样写： 1[![](https://cdn.sguan.top/markdown/20200721141223.png)](https://baidu.com) 其效果类似于这样： 点一下图片试试，看看和前一张图片的区别。 shields.io徽章其实也只是一些图片，只不过它看起来会很小，包含了一些信息，并且一般是 svg 格式的。也就是说我们只要在 README.md 中引入这种风格的图片就可以了。 一个徽章的构成元素包括：标签、信息、风格样式： 上面这个徽章，它的标签是 RELEASE，信息是 x.x.x 的一个版本号，风格比较扁平化。 问题在于我们如何生成符合自己需求的图片呢？ 答案是 shields.io，目前我们在 GitHub 上看到的很多徽章都是在这个网站生成的，该网站提供了数以百计的徽章可以选择，并且你还可以自定义徽章，这足以满意绝大部分开发者的需求。生成的图片都会有一个唯一地址，你可以直接引用该图片，或者下载图片，将其保存到项目中，再通过相对目录引用图片。无论如何，我们需要做的只是生成想要的图片、在 markdown 中引入它。 虽然有很多的徽章可以选择，但一般只需要为重要的信息添加徽章，过多的徽章会让读者无法快速提取其中的信息。至于哪些是重要的信息，这取决于具体的项目以及你自身的理解。 静态徽章对一个项目来说，某些徽章基本上不会发生变化，例如：开源协议、一些链接等。 这种徽章可以看成是静态徽章，即不会变化的徽章。 开源协议shields.io 提供了大量的静态徽章，这里我们以 开源协议 系列的徽章为例。 开源协议相关的徽章可以在 这里 看到。 点击你需要的协议，然后填入参数（这里我其实没太明白规则，一般填入 e.g. 后面的字符即可），例如： 红色圈出来的部分就是我们生成的徽章，点击下面的 Copy Badge URL 即可复制徽章图片的地址，得到的地址类似于这样： 1https://img.shields.io/aur/license/android-studio 你也可以点击 ⬇ 展开，复制其它格式的地址，不同格式的地址本质上并没有区别，例如 markdown 格式的徽章地址。 1![AUR license](https://img.shields.io/aur/license/android-studio) 调整风格此外，你可以修改参数，生成不同风格的徽章。 生成的徽章就会是风格比较扁平化的徽章。 自定义徽章如果预置的徽章都不能满足你的要求，你还可以生成自定义徽章。 shields.io 每个页面的底部都提供了自定义徽章的功能，你可以根据自己的需要填入信息、生成徽章、引用。 https://img.shields.io/badge/ID-3ks-brightgreen?style=for-the-badge https://img.shields.io/static/v1?label=NAME&amp;message=Guan&amp;color=brightgreen?style=for-the-badge https://img.shields.io/static/v1?label=&amp;message=&amp;color= 动态徽章预置自定义参考链接shields.io GitHub 项目徽章的添加和设置 如何让你的 GitHub 项目表面上更专业 为你的Github生成漂亮的徽章和进度条 Adding a workflow status badge to your repository","link":"/2020/07/17/github-badges/"},{"title":"博客切换至 Hexo","text":"最近将博客的生成器更改为了 Hexo，并使用了主题 icarus，当然，依然是静态博客。 整个迁移过程异常的顺利、简单，并且博客也比之前漂亮了很多，在这里做个笔记，算是自己的一个 icarus 入门教程吧。 背景之前使用的是 Hugo 框架生成静态博客，虽然 Hugo 宣称是世界上最快的网站生成器，且很多大佬都表示 Hugo 很简单，但我个人觉得并非如此。原因有如下几点： 性能：静态博客最终生成的都是 html、css、js，然后随便挂个 web 服务器就可以发布，撑死我每天也写不出两篇文章，此时渲染几十毫秒，和渲染几秒对我都没多大影响。 学习成本：静态博客推崇的是约定优于配置，什么意思呢？静态博客简单的代价就是很多东西都是有默认配置的，如果你想要自定义一些东西，你必须得查看文档，看看都有些什么约定、参数，都是用来干嘛的、怎么调整。在这方面，Hexo 的文档只有 24 页，而 Hugo 的文档有 100 多页，Hugo 确实更强大，但如果你想要做一些修改，也需要更高的学习成本。 这里主要是文档，Hugo 不仅有 100 多页的文档，而且还都是英文的。而 Hexo 不仅文档只有十几页，而且还有中文翻译（虽然有点滞后，但不影响了解 Hexo）。 生态：Hugo 与 Hexo 都有三百多个主题，看起来差不多，但很多主题的质量其实很差的，我不是针对谁，我是说在在座的两位。Hugo 我至今没有找到一个简单且满意的主题，而 Hexo，从找主题，到安装，简单修改，运行，一共几个小时就搞定了，丝滑般的享受，我的头发又回来了o(￣▽￣)ブ 总结一下：Hugo 很强，也很难。有多难？我觉得比 Kubernetes 还难！Hexo 各方面都很简单，优秀的主题同样可以赋予静态博客生命，如何选择取决于自己。 以下，是自己使用 Hexo 以及 icarus 主题的一点笔记。 安装 Icarus安装 node.js前往 nodejs.org 根据自己的平台下载对应的版本。 对于 Ubuntu 用户，你也可以执行以下命令： 1$ apt-get install -y npm 安装完成后查看 node 和 npm 版本信息，确保安装成功： 1234$ node --versionv12.16.1$ npm --version6.14.6 安装 Hexo在安装好 node.js 后，执行下面的命令即可： 1$ npm install hexo-cli -g 安装完成后查看 hexo 版本信息，确保安装成功： 1234567891011121314151617$ hexo -vhexo: 4.2.1hexo-cli: 3.1.0os: Linux 4.4.0-18362-Microsoft linux x64http_parser: 2.7.1node: 8.10.0v8: 6.2.414.50uv: 1.18.0zlib: 1.2.11ares: 1.14.0modules: 57nghttp2: 1.30.0openssl: 1.0.2nicu: 60.2unicode: 10.0cldr: 32.0.1tz: 2017c 初始化博客 先切换至你写代码的目录，然后初始化博客 12$ hexo init &lt;your-blog-name&gt;$ cd &lt;your-blog-name&gt;/themes 注意：your-blog-name 是一个目录名，你应该将他替换为自己需要的名字。 下载 Icarus 主题 1git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus -b &lt;version number&gt; --depth 1 注意： 是 icarus 主题的版本号，你可以在 icarus release 查看可用的版本号。 使用 Icarus 主题 编辑 _config.yml 文件，指定主题： 1$ cd ../ &amp;&amp; vi _config.yml 找到 theme 项，将值设为 icarus： _config.yml1theme: icarus 启动博客1$ hexo server 此时，可能会提示你缺少一些依赖，需要安装，比如这种： 根据给出的提示，运行安装命令就可以了。 随后你就可以访问 http://localhost:4000 查看你的博客了。 虽然此时的博客还是一个毛坯，但看起来还是挺好看的，不得不说 icarus 的作者这方面做的很好，接下来就是根据自己的需求，做一些调整了。 配置样式改动对原主题样式的修改都集中在 themes/icarus/include/style/custom.styl 文件内。 about 页和 404 页about 页面，需要创建一个 source/about/index.md 的文件来进行描述，生成的站点即可正常访问 about 页面 404 页面，需要创建一个 source/404.md 的文件来描述，会生成一个 404.html，需配合 web 服务器使用。 CDN 加速所有的静态资源，如：css、js、图片、字体文件均通过 CDN 加速，站点仅提供 html 内容。 文章的图片在写作时就直接通过图床传到 CDN 上了。 而网页的静态文件，使用的方法很土，手动修改了 themes/icarus/layout 下所有涉及引入静态资源代码的路径为 CDN 路径，可以通过关键字 自定义 CDN 找到它们。 GitHub Action使用 GitHub Action，自动部署到了 GitHub Page 和自己的服务下，相关内容可以查看 .github/workflows/ci.yml 文件 参考链接hexo.io Icarus快速上手 Icarus用户指南","link":"/2020/07/17/go-to-hexo/"},{"title":"重读 The Way to Go","text":"The Way to Go 是一本经典的 Go 语言入门教学书籍，中文译本主要由 unknown 翻译，我已经阅读过多次了，每次都会有有一些收获，入坑 Go 正好两周年，正好最近在找工作，遂再次学习了本书（指译本，下同）的内容，并将本次的收获简单做一下记录。 阅读链接项目地址：unknwon/the-way-to-go_ZH_CN 目录：directory 国内很多 Gopher 入门的第一本书就是 The Way to Go，据我所知，很多网站都能找到本书的内容。 如果你也对这本书感兴趣的话，我只推荐你通过上面的链接进行阅读。The Way to Go 这本书已经做出过多次修订，译文同样需要更新，在这方面，阅读译本原文可以获得最好的体验。 main.go查看源文件1234567package mainimport \"fmt\"func main() { fmt.Println(\"hello world\")}","link":"/2020/07/17/the-way-to-go/"},{"title":"一些 GORM 的问题","text":"GORM v2 带来了大量的改进以及新功能，其中有一些高级功能涉及到了之前没有接触过的 SQL 知识，故在此简单做下笔记。 DryRun ModePrepareStmtprepared statement 参考链接name","link":"/2020/07/28/gorm-faq/"},{"title":"复习 Mysql","text":"这不是一个完整的教程，知识我重新学习 Mysql 的知识，并做了一些零碎笔记。 别名对于字段别名可以这样： 1select name as 姓名,age from tb_user; 也可以： 1select name 姓名,age from tb_user; 多个字段用 , 分隔，字段别名可以不加 as，直接用空格分隔即可。 表别名类似，可以这样： 1select A.name from tb_user as A; 也可以： 1select A.name from tb_user A; DISTINCTdistinct 是对结果去重的，它是作用在所有选择字段上的，而不是单个字段。 例如： 1select distinct name,age from tb_user; 其效果类似于： 1select distinct (name,age) from tb_user; 如果我们想要对查询多个字段，且根据某一个字段去重，应该使用 GROUP BY： 1select name,max(age) from tb_user group by name; BETWEEN AND 边界下面的语句类似于，age &gt;= 20 &amp;&amp; age &lt;= 30 1select * from tb_user where age BETWEEN 20 AND 30; 下面的语句类似于，age &lt; 20 || age &gt; 30 1select * from tb_user where age NOT BETWEEN 20 AND 30; ESCAPE在使用 like 子句的通配符时，如果字段恰好包含了通配符怎么办呢？ 例如：在下面这个查询中，我们确实想查询包含 前5% 关键字的内容，默认情况下 % 会被视为通配符。 1select * from where tb_user where description like &quot;%前5%%&quot;; 此时我们可以使用 ESCAPE，escape 意为避开、避免，在 like 子句中，escape 字符后面的通配符会被视为普通字符： 12select * from where tb_user where description like &quot;%前5!%%&quot; escape '!'; select * from where tb_user where description like &quot;%前5#%%&quot; escape '#'; 参考链接name","link":"/2020/07/29/review-mysql/"},{"title":"Network Manager 入门","text":"Network Manager 入门笔记，完成基本的网络配置 介绍NetworkManager(NM) 是 2004 年 Red Hat 启动的项目，旨在能够让 Linux 用户更轻松地处理现代网络需求，尤其是无线网络，能自动发现网卡并配置 IP 地址。 在 rhel8/centos8 上，network.service 已被废弃，我们只能通过 NetworkManager 进行网络管理。 当然，我们不需要直接使用 NetworkManger 管理网络，我们可以通过下面这些工具进行 NetworkManger 管理，他们类似于 NetworkManger 客户端： nmcli：命令行。这是最常用的工具，本文将详细讲解该工具使用。 nmtui：在shell终端开启文本图形界面。示意图见本文最后的Tips Freedesktop applet：如GNOME上自带的网络管理工具 cockpit：redhat 自带的基于 web 图形界面的管理工具，具有 dashborad 和基础管理功能。 本文只介绍 NetworkManager 相关知识以及 nmcli 的使用方法。 概念在 NM 中，有两个主要对象：设备（device）和 连接（connection），它们是一对多的关系，即一个设备可以对应多个连接。但是，一个设备只能有一个活跃的连接，其它连接会变为非活跃、不可用。 设备（device）我们可以通过命令 nmcli d 或 nmcli device 者查看当前设备状态： 1234$ nmcli dDEVICE TYPE STATE CONNECTIONens33 ethernet connected ens33lo loopback unmanaged -- 输出包含四列，分别表示：设备名、设备类型、状态、激活地连接名。 设备名和连接名可以相同，但他们是不同的对象，在后续的操作中注意不要被同名的情况误导。 并非所有的设备都会被 NM 接管，设备常见的状态有： 状态 描述 connected 已被 NM 接管，设备当前有活跃的连接 disconnected 已被 NM 接管，设备当前没有活跃的连接 unmanaged 未被 NM 接管，但可以通过命令接管该设备 unavailable 未被 NM 接管，不可用，NM 无法接管该设备，通常由网卡被 down 掉导致，例如：ip link set ethX down NM 只能管理 已被 NM 接管 设备的网络配置。 连接（connection）我们可以通过命令 nmcli c 或 nmcli connection 者查看当前连接状态： 123$ nmcli cNAME UUID TYPE DEVICEens33 d20368c4-4112-4773-b3a5-c8d06907c349 ethernet ens33 输出包含四列，分别表示：连接名名、唯一标识 UUID、连接类型、对应的设备名。 连接的常见状态有： 状态 描述 connected 活跃的连接 disconnected 非活跃的连接 连接的状态由输出结果的颜色来判断，绿色为活跃，正常颜色为非活跃： 你也可以执行 nmcli device 根据设备的状态及其对应的连接来判断连接的状态。 基本网络配置想要正常访问互联网，需要配置：IP 配置方法（DHCP 或手动）、IP 地址、子网掩码、网关、DNS。而服务器一般使用静态 IP： 1234# 配置nmcli c mod ens33 ipv4.method 'manual' ipv4.addr '192.168.7.10/24' ipv4.gateway '192.168.7.2' ipv4.dns '8.8.8.8'# 使更改生效nmcli c up ens33 其中： 在 nmcli 中，很多关键字都支持缩写，c 是 connection 的缩写，mod 是 modify 的缩写，d 是 device 的缩写。 并不是每一个连接都要配置 DNS，因为默认情况下，有一个系统默认的全局 DNS（/etc/resolve.conf）。只有当你需要为这个连接指定特别的 DNS 时才需要配置。 ipv4.addr 等属性列表，可以通过命令 nmcli c show ens33 查看，然后根据自己的需要进行修改。 创建连接1234# 创建连接nmcli c add type ethernet ifname ens33 con-name eth0 ipv4.method 'manual' ipv4.addr '192.168.7.11/24' ipv4.gateway '192.168.7.2'# 激活（切换）连接nmcli c up eth0 其中： type ethernet 指定连接类型 ifname ens33 指定对应的设备名 con-name eth0 指定连接名，可以忽略，此时会自动生成连接名 ipv4.method 等后续配置，可以在创建时就指定，也可以创建好链接后，再修改 eth0 激活后，之前的 ens33 连接会变为非活跃状态 设备是否（例如开机）自动连接可以通过 nmcli d set &lt;ifname&gt; [autoconnect yes|no] [managed yes|no] 来配置 多个 IP虽然一个设备只能有一个激活的连接，但这不代表只能有一个 IP，我们可以通过以下方式添加多个 IP 单连接多 IP12nmcli c mod eth0 +ipv4.addr '192.168.7.12/24'nmcli c up eth0 注意，ipv4.addr 前面有一个 + 表示追加，对应的，还可以使用 - 表示移除，而无符号则表示覆盖 桥接123456# 添加桥接连接nmcli c add type bridge ifname eth1 con-name eth1# 配置 IPnmcli c mod eth1 ipv4.method 'manual' ipv4.addr '172.16.1.10/16' ipv4.gateway '172.16.0.2'# 激活nmcli c up eth1 其中： type bridge 表示添加一个桥接连接，同时它会自动创建一个桥接设备，形成逻辑上的两个设备，这样我们就可以同时有两个活跃的连接 其它-hnmcli 拥有很完整的帮助文档，在使用时你可以经常加上 -h 查看。简单来讲，主要就是 connection 和 device 对象的增删改查。 命令补全nmcli 不仅支持命令缩写，还支持 tab 命令补全，前提是安装 bash-completion，可以通过如下命令安装它： 1dnf install -y bash-completion 完成后，重新登录一下即可。 参考链接基于RHEL8/CentOS8的网络IP配置详解 使用 NETWORKMANAGER 命令行工具 NMCLI （由 RedHat 提供的文档，并且提供了中文版）","link":"/2020/08/25/network-manager/"},{"title":"alias 使用","text":"一个简单实用的命令，通过 alias 命令设置一个别名，比如 alias c='clear' 可以让输入 c 与 clear 的效果是相同的。 alias 的用法非常简单： 1$ alias 别名='原命令 -选项/参数' alias 命令有两种使用方式，在命令行中直接使用、将命令写入至 bashrc 文件，而写入 bashrc 文件又分为写入用户文件和系统文件。 命令中行使用1$ alias cdgo='cd /go/src/github.com/3ks/3ks.dev' alias 会立即生效，但只会在本次会话生效，对于其它会话（包括其他用户、该用户的其它会话）都无效。 写入用户 bashrc 文件将 alias 写入用户 bashrc 文件可以带来永久的效果，这些 alias 对该用户有效，该文件位于 ~/.bashrc： ~/.bashrc1$ alias cdgo='cd /go/src/github.com' 保存退出后，执行下面的命令使之生效： 1source ~/.bashrc 写入系统 bashrc 文件将 alias 写入系统 bashrc 文件可以带来永久的效果，这些 alias 对系统中的所有用户有效，该文件位于 /etc/bashrc： ~/.bashrc1$ alias cdgo='cd /go' 保存退出后，执行下面的命令使之生效： 1source ~/.bashrc alias 优先级对于存在冲突的 alias，命令行优先于用户 bashrc 文件优先于系统 bashrc 文件 参考链接alias命令","link":"/2020/08/26/alias/"},{"title":"各种简写及其含义","text":"一些简写的全写及其含义。 目的在 GitHub 的开源项目中与他们协作时，会用到大量的缩写字母。 这并不是什么高大上的东西，甚至说有点土。不信？来看几个例子 gkd、dbq、xjj、xgg ，什么意思呢？其实这种汉语拼音的首字母缩写，意思是 搞快点、对不起、小姐姐、小哥哥。是不是瞬间觉得很土了！听说现在的 00 后们很喜欢这种 缩写体 聊天方式。 什么，你接受不了？不管你是 70 后、80 后还是 90 后。gg、mm、886、520 总用过吧！当年 40 后、50 后、60 后也受不了你们！ 这些简写字母其实是各种短语的 首字母 或 首字母谐音 缩写，目的是为了方便多人协作和交流。 其实我认为这些缩写本质上来说，是一种简单高效的交流方式，只是需要花点时间去学习，了解其含义。 本文会介绍英文中的一些单词首字母缩写及其含义，主要分为三类，英文单词缩写、汉语拼音缩写和开源协作类缩写。 其中开源协作类的内容会稍微复杂一点，主要面向 开发者 人群做介绍，因为其可能不仅仅是表达某种意思，还会被 机器人 视为 指令 并做一些自动化处理，所以还会介绍其作用，以及在什么哪一个仓库有效。既然说到了自动化处理，还会介绍一些其它的非缩写的 指令。好吧，其实我主要是想说的 Kubernetes 相关的仓库。 英文单词缩写体老美们懒惰腐败的交流方式： 缩写 原文 含义 R U OK? are you ok? 你还好吗？ NG no good 不够好（一般指导演认为不够好，需要重拍） GG good game 一局精彩的游戏 NGG no good game 这不是一局精彩的游戏 bashrc bash run command bashrc 一般是某个文件，在一个新建 bash 开始时，会执行 bashrc 中的命令，可以将其看成一个初始化脚本 汉语拼音缩写体深受小鲜肉们喜爱的聊天交流方式。 缩写 原文 出处 awsl 阿伟死了 - xswl 笑死我了 - gkd 搞快点 - 开源协作类这一部分的前 3 列 非开发者 人群也可以阅读，本质上还是一些英文缩写，可以了解一下 程序员 们是如何进行全球协作开发的。 一般的指令都会 @someone 某个人，这跟你在微博上 @某个人 是一样的意思。 后面几列专业性稍强，主要面向 程序员 做介绍。 这一部分的内容会有缩写、缩写指令、非缩写指令三种类型，主要介绍在 Kubernetes 系的开源仓库中协作时会用到的一些缩写。 缩写 原文 含义 k8s bot 动作 /cc @someone see see 看看（请帮我 review 一下代码） 自动将你 @ 的人添加至 reviewer 列表，表示你希望此人帮你 review 代码。 /cc @someone see see 看看（请帮我 review 一下代码） 自动将你 @ 的人添加至 reviewer 列表，表示你希望此人帮你 review 代码。 LTLR Too Long To Read 内容很长警告！ - GA General Availability 一般指某软件的首个可用版本 - 参考链接聊天字母缩写曝光：你对00后的世界一无所知","link":"/2020/08/26/argot/"},{"title":"fork 炸弹","text":"偶然看到一串奇怪的命令，手贱执行了一下，没想到系统直接卡死 完全的代码1alias clear=':(){ :|: &amp;};:' 一次偶然的机会，我看到了上面这段代码，然后手贱执行了一下： 1:(){ :|: &amp;};: 电脑直接就卡死了，过了几分钟，我才回过神来，是这段代码导致的。 网上搜了一下，这段代码就是著名的 fork bomb 即 fork 炸弹，其会以指数级的速度快速创建线程，迅速将整个系统的资源完全占用，最终导致系统卡死。 fork 炸弹一旦引爆，基本只能重启。 代码解析最开是看到这段代码一脸懵逼，怎么就卡死了呢，网上搜了一下，大致了解了其工作流程。 在这一行代码中，我们定义了一个名为 : 的函数： 1:(){ :|: &amp;};: 上面这段代码可以翻译为： 1bomb(){ bomb|bomb &amp;};bomb 再展开一下： 1234bomb(){ bomb|bomb &amp;};bomb 这样看起来就直观多了，前三行定义了一个函数，第四行调用了该函数。 而函数的行为是：后台的、通过管道递归调用自身两次 由于管道操作会创建新的进程，所以每次调用函数都会产生两份拷贝，这样函数就会呈指数级的增长，可以在极短的时间内耗光计算机资源。 参考链接fork 炸弹","link":"/2020/08/26/fork-bomb/"},{"title":"在 Centos 8 上安装 Docker","text":"一个安装 Docker 的笔记 手动安装 containerd.io1Problem: package docker-ce-3:19.03.4-3.el7.x86_64 requires containerd.io &gt;= 1.2.2-3 如果你收到类似上面这种提示，则需要手动安装 containerd.io 目前 docker 版本已经来到 19+，其对组件 containerd.io 的要求是 &gt;= 1.2.2-3，由于 Centos 软件源更新不及时（后续版本更新后这个问题可能就不存在了），默认源下没有符合要求的版本，所以该组件无法完成安装，这里我们需要手动安装 containerd.io 安装通过阿里云镜像安装： 1dnf install https://mirrors.aliyun.com/docker-ce/linux/centos/7/x86_64/stable/Packages/containerd.io-1.2.6-3.3.el7.x86_64.rpm 如果你的服务器在国外，或者网络足够好的化，也可以直接从 docker 官方下载安装： 1dnf install https://download.docker.com/linux/centos/7/x86_64/stable/Packages/containerd.io-1.2.6-3.3.el7.x86_64.rpm 此外，上面的命令中的 rpm 包可能随着时间的推移而变得陈久，但你可以直接访问 Docker 官方 或者 阿里云镜像 查看并选择最新的 rpm 包。 安装 Docker添加仓库添加 Docker 官方的仓库信息： 12$ sudo yum install -y yum-utils$ sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo 安装正常的 Docker 安装： 1$ sudo yum install docker-ce docker-ce-cli 启动并添加开机启动项1$ sudo systemctl enable --now docker 验证1$ sudo docker run hello-world 等待镜像启动完成后，如果你可以看到的内容类似于下面这样，则表示安装成功： 12345678910111213141516171819202122$ sudo docker run hello-worldHello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal.To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bashShare images, automate workflows, and more with a free Docker ID: https://hub.docker.com/For more examples and ideas, visit: https://docs.docker.com/get-started/ 镜像加速由于网络方面的原因，我们在拉取镜像的时候速度可能会很慢，对此，我们可以通过编辑配置文件，配置镜像来加快其速度。 在 Linux 系统中，默认情况下，Docker 的配置文件是 /etc/docker/daemon.json（Configure the Docker daemon） /etc/docker/daemon.json123{ \"registry-mirrors\": [\"http://hub-mirror.c.163.com\"]} 配置好镜像后，你需要执行以下命令： 12$ systemctl daemon-reload $ systemctl restart docker 安装 Docker Compose12$ sudo curl -L \"https://github.com/docker/compose/releases/download/1.26.2/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose$ sudo chmod +x /usr/local/bin/docker-compose 随后，你可以运行下面的命令查看 Docker Compose 版本，并以此判断是否安装成功： 12$ docker-compose -vdocker-compose version 1.26.2, build eefe0d31 Docker Compose 可用于单机简单的编排，在学习、测试时是一个不错的选择。对于更加复杂的容器编排，唯一的选择是 Kubernetes 卸载卸载 Docker Compose1sudo rm /usr/local/bin/docker-compose 卸载 Docker1$ sudo yum remove docker-ce docker-ce-cli containerd.io 但是，相关的镜像、容器、卷以及其它自定义目录下的内容不会被自动删除，你需要自己手动删除它们： 123$ sudo rm -rf /var/lib/docker# 删除其它自定义目录$ sudo rm -rf ... 参考链接Install Docker Engine on CentOS CentOS之——CentOS8 安装 Docker Install Docker Compose","link":"/2020/08/26/install-docker-on-centos-8/"}],"tags":[{"name":"CentOS","slug":"CentOS","link":"/tags/CentOS/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"GitHub","slug":"GitHub","link":"/tags/GitHub/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"cache","slug":"cache","link":"/tags/cache/"},{"name":"swap","slug":"swap","link":"/tags/swap/"},{"name":"Badge","slug":"Badge","link":"/tags/Badge/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"icarus","slug":"icarus","link":"/tags/icarus/"},{"name":"CDN","slug":"CDN","link":"/tags/CDN/"},{"name":"GitHub Page","slug":"GitHub-Page","link":"/tags/GitHub-Page/"},{"name":"GitHub Action","slug":"GitHub-Action","link":"/tags/GitHub-Action/"},{"name":"go","slug":"go","link":"/tags/go/"},{"name":"todo","slug":"todo","link":"/tags/todo/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"mysql 8.0","slug":"mysql-8-0","link":"/tags/mysql-8-0/"},{"name":"NetworkManager","slug":"NetworkManager","link":"/tags/NetworkManager/"},{"name":"NM","slug":"NM","link":"/tags/NM/"},{"name":"command","slug":"command","link":"/tags/command/"},{"name":"alias","slug":"alias","link":"/tags/alias/"},{"name":"argot","slug":"argot","link":"/tags/argot/"},{"name":"黑话","slug":"黑话","link":"/tags/%E9%BB%91%E8%AF%9D/"},{"name":"security","slug":"security","link":"/tags/security/"},{"name":"fork bomb","slug":"fork-bomb","link":"/tags/fork-bomb/"},{"name":"docker-compose","slug":"docker-compose","link":"/tags/docker-compose/"},{"name":"centos8","slug":"centos8","link":"/tags/centos8/"}],"categories":[{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"Github","slug":"Github","link":"/categories/Github/"},{"name":"CentOS","slug":"Linux/CentOS","link":"/categories/Linux/CentOS/"},{"name":"blog","slug":"blog","link":"/categories/blog/"},{"name":"go","slug":"go","link":"/categories/go/"},{"name":"todo","slug":"todo","link":"/categories/todo/"},{"name":"database","slug":"database","link":"/categories/database/"},{"name":"Badge","slug":"Github/Badge","link":"/categories/Github/Badge/"},{"name":"network","slug":"network","link":"/categories/network/"},{"name":"command","slug":"command","link":"/categories/command/"},{"name":"argot","slug":"argot","link":"/categories/argot/"},{"name":"cache","slug":"Linux/CentOS/cache","link":"/categories/Linux/CentOS/cache/"},{"name":"security","slug":"security","link":"/categories/security/"},{"name":"docker","slug":"docker","link":"/categories/docker/"},{"name":"hexo","slug":"blog/hexo","link":"/categories/blog/hexo/"},{"name":"the-way-to-go","slug":"go/the-way-to-go","link":"/categories/go/the-way-to-go/"},{"name":"swap","slug":"Linux/CentOS/swap","link":"/categories/Linux/CentOS/swap/"},{"name":"mysql","slug":"database/mysql","link":"/categories/database/mysql/"},{"name":"NetworkManager","slug":"network/NetworkManager","link":"/categories/network/NetworkManager/"},{"name":"alias","slug":"command/alias","link":"/categories/command/alias/"},{"name":"icarus","slug":"blog/hexo/icarus","link":"/categories/blog/hexo/icarus/"}]}