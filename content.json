{"pages":[{"title":"","text":"找不到这个奇怪的链接！点击返回首页","link":"/404.html"},{"title":"欢迎访问","text":"您好，欢迎访问我的博客。 博客说明一个没什么技术含量的博客，内容大都不成体系，主要是一些自己的学习笔记，不对的地方请多多指教。 静态博客基于 Hexo，使用主题 icarus CDN除 html 文件外，几乎所有的静态文件都通过 CDN 加速。虽然服务器在美国，但访问速度还是不错 GitHub Action基于 GitHub Action 实现 CI/CD，分别部署到了 https://3ks.dev 和 https://3ks.github.io 一个由自己的服务器提供服务，一个由 GitHub Page 托管，其中一个挂掉，也可以访问另一个，两者内容完全一致 我是官余棚，朋友们一般叫我官二、官二代，来自重庆，农民的儿子，一个吃瓜群众 重庆师范大学计算机科学与技术 2019 届毕业生。 职业21 世纪的农民——码农，目前正在寻找上海地区 Golang 或云原生方向的工作。 标签学以致用、强迫症、爱折腾、有思想、爱自由、死肥宅、内向、友善、杠精、专一 爱好宅、肉、美剧、4K/蓝光电影、3C 产品、可口可乐、英雄联盟 开源贡献大部分都是一些没什么技术含量的贡献，但我不认为自己所做的事情没有意义，我把这看作是一个学习、积累的过程 开源组织侥幸混进了一些开源组织，请访问 https://github.com/3ks 查看。 Golang 基础 gobyexample-cn/gobyexample polaris1119/The-Golang-Standard-Library-by-Example unknwon/the-way-to-go_ZH_CN Golang 应用 google/go-github gin-gonic/website go-gorm/gorm.io facebookincubator/ent Golang 及云原生 servicemesher/istio-handbook servicemesher/istio-official-translation kubernetes/website istio/istio.io 计算机基础 CyC2018/CS-Notes 前端 ppoffice/hexo-theme-icarus 火箭 🚀 chrislgarry/Apollo-11 r-spacex/SpaceX-API 为什么是 3ks我的 GitHub ID 是 3ks，所以就申请了 3ks.dev 域名 为什么是 3ks 呢？很简单，因为短，对于 ID 这种东西，个人认为越短越好（深受 QQ 号荼毒） 并且 3ks 的中文发音与 tks 相同，意为谢谢。同时，谢谢 也是我的口头禅 别问我为什么不用 tks，我是不会告诉你已经被别人占用了的😒 自我评价一个资质平平的普通人 在领略全球顶级的开发者的风采、见识十几岁天才的资质后，我认识到自己：只是一个凭着爱好碰巧进入了这个行业的普通人而已 虽然世界是由天才来改变的，但天才毕竟只是极少数，普通人也有普通人要做的事，普通人也能为世界更美好贡献一份力量 联系方式 邮箱：1@linux.com GitHub：https://github/3ks","link":"/about/index.html"}],"posts":[{"title":"Linux 清理缓存","text":"以下几条命令用于清理不同类型的缓存。 清除页面缓存（PageCache）下面的命令只会清理掉页面缓存，对于生产环境来说是比较安全的。 1$ echo 1 &gt; /proc/sys/vm/drop_caches 清除目录项和 inode1$ echo 2 &gt; /proc/sys/vm/drop_caches 清除页面缓存、目录项和 inode下面的命令会将缓存完全清除，随后可能导致系统变慢，因为很多应用程序的缓存失效后，会从数据源读取数据（例如硬盘、API 等）。 不建议在生成环境用使用该命令，除非你知道自己在做什么： 1$ echo 3 &gt; /proc/sys/vm/drop_caches 注意事项适用场景建议仅在测试和调试场景使用。 清理该文件不应该作为控制内存使用的手段，缓存是由程序申请并使用的，它往往会带来程序效率的提升（如减少磁盘访问频率），内存开销过大一般应该从程序优化角度考虑。如果你强行清理掉缓存，反而可能带来性能损失，因为一些程序在缓存失效后，会消耗大量的 I/O 和 CPU 来重建缓存。 非破坏性的实际上，上面的清除操作都不是破坏性的操作，即它们都不会清除脏对象，因此你不必担心未同步的文件会被清除掉。 但换个角度来看，这在一定程度上会减少清理缓存的效果，因为脏对象没有被清理。 此时我们可以在清除缓存前，执行 sync 命令，先同步文件，减少脏对象的数量，以提高清理效果。例如： 1$ sync; echo 1 &gt; /proc/sys/vm/drop_caches 问题（TODO）虽然到处都在说 1、2、3 分别代表清除不同类型的缓存，但从来没有人说过为什么 echo 不同的数字会带来不同的效果。 其用法在 Kernel Documentation （关键字 drop_caches） 可以找到。但同样只写了用法与效果，没有提到原理。 个人猜测这是 Kernel 拦截了对 drop_caches 文件的写入，并根据不同值做出不同处理 以后有机会再看看… 参考链接在 Linux 上如何清除内存的 Cache、Buffer 和交换空间 Kernel Documentation Hibernate中的脏检查和缓存清理机制","link":"/2020/07/14/clean-cache/"},{"title":"Hello World","text":"欢迎 来到 Hexo! 普通文本Hello World 图片 引用 一个肮脏的国家，如果人人讲规则而不是空谈道德，最终会变成一个有人味儿的正常国家，道德自然会逐渐回归；反之，一个干净的国家，如果人人都不讲规则却大谈道德、谈高尚，天天没事儿就谈道德规范，人人大公无私，最终这个国家会堕落成为一个伪君子遍布的肮脏国家。——沙雕网友 表格 日期 天气 气温 湿度 2020-07-13 晴 33℃ 95% 2020-07-14 阴 28℃ 97% 2020-07-15 小雨 25℃ 99% 纯文本块123Hello WorldWelcome! shell 脚本片段1$ echo \"hello world\" GO 代码main.go查看源文件1234567package mainimport \"fmt\"func main() { fmt.Println(\"hello world\")} JSON 片段1234{\"title\": \"hello world\",\"themes\": \"icarus\"} YAML 片段config.yml12\"title\": \"hello world\"\"themes\": \"icarus\" 一级标题普通文本 二级标题普通文本 三级标题普通文本 四级标题普通文本","link":"/2020/07/14/hello-world/"},{"title":"CentOS 分配和禁用 swap 空间","text":"云服务的内存不够，也没有自动分配 swap 空间，导致 mysql 服务器无法启动。 此时我们可以自己分配 swap 空间作为缓存，个人感觉 swap 类似于 windows 里的虚拟内存。 分配并启用 swap获取硬盘设备路径1$ df -h 分配空间4G1$ sudo dd if=/dev/vda1 of=/swapfile count=4096 bs=1MiB DO 文档里面的 sudo fallocate -l 4G /swapfile 是错误的，评论区出人才！ 权限设置12$ sudo chmod 600 /swapfile$ sudo mkswap /swapfile 制作 swap 系统，如果成功会有一个类似下面的提示： 12Setting up swapspace version 1, size = 4194300 KiBno label, UUID=b99230bb-21af-47bc-8c37-de41129c39bf 启动 swap1$ sudo swapon /swapfile 查看结果1free -m 检查 swap 是否已经在运行、有容量了。 开机自动挂载在文件 /etc/sysctl.conf 末尾追加内容、并保存 /etc/sysctl.conf1/swapfile swap swap sw 0 0 禁用系统默认的 swap 分区某些场景下，不能使用 swap 分区，此时则应该禁用 swap 分区： 取消挂载编辑 /etc/fstab 文件，取消 swap 分区的挂载： /etc/fstab123456789# /etc/fstab# Created by anaconda on Sat Feb 29 05:30:30 2020## Accessible filesystems, by reference, are maintained under '/dev/disk'# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info#/dev/mapper/centos-root / xfs defaults 0 0UUID=666d6259-55da-4501-91fb-40b2c0b16ca2 /boot xfs defaults 0 0/dev/mapper/centos-swap swap swap defaults 0 0 swap 文件系统那一行对应的路径就是目前挂载的 swap 分区。 我们将这一行删掉，或者注释掉，保存退出。 下次系统启动时就不会自动挂载该 swap 分区。 如果不想重启系统，根据 swap 分区的路径，执行下面的命令即可立即禁用 swap 分区。 1$ swapoff /dev/mapper/centos-swap 释放分区todo 参考链接How To Add Swap on CentOS 7 CentOS 7 关闭 swap 分区","link":"/2020/07/14/malloc-swap/"},{"title":"如何为你的 GitHub 项目添加 badge","text":"我们在很多开源项目的 README 都能看到大量的徽章（badge），这些徽章大都挺漂亮的，最重要的是，通过这些徽章，我们可以快速的获取项目的状态信息，例如：开源协议、版本、单元测试覆盖率等。 那我们应该如何为自己的项目加上一些徽章呢？ markdown 与图片markdown 插入图片我们都知道项目的 README 是一个 markdown 文件，在 markdown 内可以这样插入一张图片 1![](https://cdn.sguan.top/markdown/20200721141223.png) 其效果类似于这样： markdown 插入图片链接此外，如果我们想在点击图片后，跳转到某个页面，可以这样写： 1[![](https://cdn.sguan.top/markdown/20200721141223.png)](https://baidu.com) 其效果类似于这样： 点一下图片试试，看看和前一张图片的区别。 shields.io徽章其实也只是一些图片，只不过它看起来会很小，包含了一些信息，并且一般是 svg 格式的。也就是说我们只要在 README.md 中引入这种风格的图片就可以了。 一个徽章的构成元素包括：标签、信息、风格样式： 上面这个徽章，它的标签是 RELEASE，信息是 x.x.x 的一个版本号，风格比较扁平化。 问题在于我们如何生成符合自己需求的图片呢？ 答案是 shields.io，目前我们在 GitHub 上看到的很多徽章都是在这个网站生成的，该网站提供了数以百计的徽章可以选择，并且你还可以自定义徽章，这足以满意绝大部分开发者的需求。生成的图片都会有一个唯一地址，你可以直接引用该图片，或者下载图片，将其保存到项目中，再通过相对目录引用图片。无论如何，我们需要做的只是生成想要的图片、在 markdown 中引入它。 虽然有很多的徽章可以选择，但一般只需要为重要的信息添加徽章，过多的徽章会让读者无法快速提取其中的信息。至于哪些是重要的信息，这取决于具体的项目以及你自身的理解。 静态徽章对一个项目来说，某些徽章基本上不会发生变化，例如：开源协议、一些链接等。 这种徽章可以看成是静态徽章，即不会变化的徽章。 开源协议shields.io 提供了大量的静态徽章，这里我们以 开源协议 系列的徽章为例。 开源协议相关的徽章可以在 这里 看到。 点击你需要的协议，然后填入参数（这里我其实没太明白规则，一般填入 e.g. 后面的字符即可），例如： 红色圈出来的部分就是我们生成的徽章，点击下面的 Copy Badge URL 即可复制徽章图片的地址，得到的地址类似于这样： 1https://img.shields.io/aur/license/android-studio 你也可以点击 ⬇ 展开，复制其它格式的地址，不同格式的地址本质上并没有区别，例如 markdown 格式的徽章地址。 1![AUR license](https://img.shields.io/aur/license/android-studio) 调整风格此外，你可以修改参数，生成不同风格的徽章。 生成的徽章就会是风格比较扁平化的徽章。 自定义徽章如果预置的徽章都不能满足你的要求，你还可以生成自定义徽章。 shields.io 每个页面的底部都提供了自定义徽章的功能，你可以根据自己的需要填入信息、生成徽章、引用。 https://img.shields.io/badge/ID-3ks-brightgreen?style=for-the-badge https://img.shields.io/static/v1?label=NAME&amp;message=Guan&amp;color=brightgreen?style=for-the-badge https://img.shields.io/static/v1?label=&amp;message=&amp;color= 动态徽章预置自定义参考链接shields.io GitHub 项目徽章的添加和设置 如何让你的 GitHub 项目表面上更专业 为你的Github生成漂亮的徽章和进度条 Adding a workflow status badge to your repository","link":"/2020/07/17/github-badges/"},{"title":"博客切换至 Hexo","text":"最近将博客的生成器更改为了 Hexo，并使用了主题 icarus，当然，依然是静态博客。 整个迁移过程异常的顺利、简单，并且博客也比之前漂亮了很多，在这里做个笔记，算是自己的一个 icarus 入门教程吧。 背景之前使用的是 Hugo 框架生成静态博客，虽然 Hugo 宣称是世界上最快的网站生成器，且很多大佬都表示 Hugo 很简单，但我个人觉得并非如此。原因有如下几点： 性能：静态博客最终生成的都是 html、css、js，然后随便挂个 web 服务器就可以发布，撑死我每天也写不出两篇文章，此时渲染几十毫秒，和渲染几秒对我都没多大影响。 学习成本：静态博客推崇的是约定优于配置，什么意思呢？静态博客简单的代价就是很多东西都是有默认配置的，如果你想要自定义一些东西，你必须得查看文档，看看都有些什么约定、参数，都是用来干嘛的、怎么调整。在这方面，Hexo 的文档只有 24 页，而 Hugo 的文档有 100 多页，Hugo 确实更强大，但如果你想要做一些修改，也需要更高的学习成本。 这里主要是文档，Hugo 不仅有 100 多页的文档，而且还都是英文的。而 Hexo 不仅文档只有十几页，而且还有中文翻译（虽然有点滞后，但不影响了解 Hexo）。 生态：Hugo 与 Hexo 都有三百多个主题，看起来差不多，但很多主题的质量其实很差的，我不是针对谁，我是说在在座的两位。Hugo 我至今没有找到一个简单且满意的主题，而 Hexo，从找主题，到安装，简单修改，运行，一共几个小时就搞定了，丝滑般的享受，我的头发又回来了o(￣▽￣)ブ 总结一下：Hugo 很强，也很难。有多难？我觉得比 Kubernetes 还难！Hexo 各方面都很简单，优秀的主题同样可以赋予静态博客生命，如何选择取决于自己。 以下，是自己使用 Hexo 以及 icarus 主题的一点笔记。 安装 node.js前往 nodejs.org 根据自己的平台下载对应的版本。 对于 Ubuntu 用户，你也可以执行以下命令： 1$ apt-get install -y npm 安装完成后查看 node 和 npm 版本信息，确保安装成功： 1234$ node --versionv12.16.1$ npm --version6.14.6 安装 Hexo在安装好 node.js 后，执行下面的命令即可： 1$ npm install hexo-cli -g 安装完成后查看 hexo 版本信息，确保安装成功： 1234567891011121314151617$ hexo -vhexo: 4.2.1hexo-cli: 3.1.0os: Linux 4.4.0-18362-Microsoft linux x64http_parser: 2.7.1node: 8.10.0v8: 6.2.414.50uv: 1.18.0zlib: 1.2.11ares: 1.14.0modules: 57nghttp2: 1.30.0openssl: 1.0.2nicu: 60.2unicode: 10.0cldr: 32.0.1tz: 2017c 初始化博客并下载 Icarus 主题 先切换至你写代码的目录，然后初始化博客 12$ hexo init &lt;your-blog-name&gt;$ cd &lt;your-blog-name&gt;/themes 注意：your-blog-name 是一个目录名，你应该将他替换为自己需要的名字。 下载 Icarus 主题 1git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus -b &lt;version number&gt; --depth 1 注意： 是 icarus 主题的版本号，你可以在 icarus release 查看可用的版本号。 使用 Icarus 主题 编辑 _config.yml 文件，指定主题： 1$ cd ../ &amp;&amp; vi _config.yml 找到 theme 项，将值设为 icarus： _config.yml1theme: icarus 启动博客1$ hexo server 此时，可能会提示你缺少一些依赖，需要安装，比如这种： 根据给出的提示，运行安装命令就可以了。 随后你就可以访问 http://localhost:4000 查看你的博客了。 虽然此时的博客还是一个毛坯，但看起来还是挺好看的，不得不说 icarus 的作者这方面做的很好，接下来就是根据自己的需求，做一些调整了。 样式改动对原主题样式的修改都集中在 themes/icarus/include/style/custom.styl 文件内。 about 页和 404 页about 页面，需要创建一个 source/about/index.md 的文件来进行描述，生成的站点即可正常访问 about 页面 404 页面，需要创建一个 source/404.md 的文件来描述，会生成一个 404.html，需配合 web 服务器使用。 CDN 加速所有的静态资源，如：css、js、图片、字体文件均通过 CDN 加速，站点仅提供 html 内容。 文章的图片在写作时就直接通过图床传到 CDN 上了。 而网页的静态文件，使用的方法很土，手动修改了 themes/icarus/layout 下所有涉及引入静态资源代码的路径为 CDN 路径，可以通过关键字 自定义 CDN 找到它们。 GitHub Action使用 GitHub Action，自动部署到了 GitHub Page 和自己的服务下，相关内容可以查看 .github/workflows/ci.yml 文件 参考链接hexo.io Icarus快速上手 Icarus用户指南","link":"/2020/07/17/go-to-hexo/"},{"title":"重读 The Way to Go","text":"The Way to Go 是一本经典的 Go 语言入门教学书籍，中文译本主要由 unknown 翻译，我已经阅读过多次了，每次都会有有一些收获，入坑 Go 正好两周年，正好最近在找工作，遂再次学习了本书（指译本，下同）的内容，并将本次的收获简单做一下记录。 阅读链接项目地址：unknwon/the-way-to-go_ZH_CN 目录：directory 国内很多 Gopher 入门的第一本书就是 The Way to Go，据我所知，很多网站都能找到本书的内容。 如果你也对这本书感兴趣的话，我只推荐你通过上面的链接进行阅读。The Way to Go 这本书已经做出过多次修订，译文同样需要更新，在这方面，阅读译本原文可以获得最好的体验。 main.go查看源文件1234567package mainimport \"fmt\"func main() { fmt.Println(\"hello world\")}","link":"/2020/07/17/the-way-to-go/"},{"title":"一些 GORM 的问题","text":"GORM v2 带来了大量的改进以及新功能，其中有一些高级功能涉及到了之前没有接触过的 SQL 知识，故在此简单做下笔记。 DryRun ModePrepareStmtprepared statement 参考链接name","link":"/2020/07/28/gorm-faq/"},{"title":"复习 Mysql","text":"这不是一个完整的教程，知识我重新学习 Mysql 的知识，并做了一些零碎笔记。 别名对于字段别名可以这样： 1select name as 姓名,age from tb_user; 也可以： 1select name 姓名,age from tb_user; 多个字段用 , 分隔，字段别名可以不加 as，直接用空格分隔即可。 表别名类似，可以这样： 1select A.name from tb_user as A; 也可以： 1select A.name from tb_user A; DISTINCTdistinct 是对结果去重的，它是作用在所有选择字段上的，而不是单个字段。 例如： 1select distinct name,age from tb_user; 其效果类似于： 1select distinct (name,age) from tb_user; 如果我们想要对查询多个字段，且根据某一个字段去重，应该使用 GROUP BY： 1select name,max(age) from tb_user group by name; BETWEEN AND 边界下面的语句类似于，age &gt;= 20 &amp;&amp; age &lt;= 30 1select * from tb_user where age BETWEEN 20 AND 30; 下面的语句类似于，age &lt; 20 || age &gt; 30 1select * from tb_user where age NOT BETWEEN 20 AND 30; ESCAPE在使用 like 子句的通配符时，如果字段恰好包含了通配符怎么办呢？ 例如：在下面这个查询中，我们确实想查询包含 前5% 关键字的内容，默认情况下 % 会被视为通配符。 1select * from where tb_user where description like &quot;%前5%%&quot;; 此时我们可以使用 ESCAPE，escape 意为避开、避免，在 like 子句中，escape 字符后面的通配符会被视为普通字符： 12select * from where tb_user where description like &quot;%前5!%%&quot; escape '!'; select * from where tb_user where description like &quot;%前5#%%&quot; escape '#'; 参考链接name","link":"/2020/07/29/review-mysql/"},{"title":"Network Manager 入门","text":"Network Manager 入门笔记，完成基本的网络配置 介绍NetworkManager(NM) 是 2004 年 Red Hat 启动的项目，旨在能够让 Linux 用户更轻松地处理现代网络需求，尤其是无线网络，能自动发现网卡并配置 IP 地址。 在 rhel8/centos8 上，network.service 已被废弃，我们只能通过 NetworkManager 进行网络管理。 当然，我们不需要直接使用 NetworkManger 管理网络，我们可以通过下面这些工具进行 NetworkManger 管理，他们类似于 NetworkManger 客户端： nmcli：命令行。这是最常用的工具，本文将详细讲解该工具使用。 nmtui：在shell终端开启文本图形界面。示意图见本文最后的Tips Freedesktop applet：如GNOME上自带的网络管理工具 cockpit：redhat 自带的基于 web 图形界面的管理工具，具有 dashborad 和基础管理功能。 本文只介绍 NetworkManager 相关知识以及 nmcli 的使用方法。 概念在 NM 中，有两个主要对象：设备（device）和 连接（connection），它们是一对多的关系，即一个设备可以对应多个连接。但是，一个设备只能有一个活跃的连接，其它连接会变为非活跃、不可用。 设备（device）我们可以通过命令 nmcli d 或 nmcli device 者查看当前设备状态： 1234$ nmcli dDEVICE TYPE STATE CONNECTIONens33 ethernet connected ens33lo loopback unmanaged -- 输出包含四列，分别表示：设备名、设备类型、状态、激活地连接名。 设备名和连接名可以相同，但他们是不同的对象，在后续的操作中注意不要被同名的情况误导。 并非所有的设备都会被 NM 接管，设备常见的状态有： 状态 描述 connected 已被 NM 接管，设备当前有活跃的连接 disconnected 已被 NM 接管，设备当前没有活跃的连接 unmanaged 未被 NM 接管，但可以通过命令接管该设备 unavailable 未被 NM 接管，不可用，NM 无法接管该设备，通常由网卡被 down 掉导致，例如：ip link set ethX down NM 只能管理 已被 NM 接管 设备的网络配置。 连接（connection）我们可以通过命令 nmcli c 或 nmcli connection 者查看当前连接状态： 123$ nmcli cNAME UUID TYPE DEVICEens33 d20368c4-4112-4773-b3a5-c8d06907c349 ethernet ens33 输出包含四列，分别表示：连接名名、唯一标识 UUID、连接类型、对应的设备名。 连接的常见状态有： 状态 描述 connected 活跃的连接 disconnected 非活跃的连接 连接的状态由输出结果的颜色来判断，绿色为活跃，正常颜色为非活跃： 你也可以执行 nmcli device 根据设备的状态及其对应的连接来判断连接的状态。 基本网络配置想要正常访问互联网，需要配置：IP 配置方法（DHCP 或手动）、IP 地址、子网掩码、网关、DNS。而服务器一般使用静态 IP： 1234# 配置nmcli c mod ens33 ipv4.method 'manual' ipv4.addr '192.168.7.10/24' ipv4.gateway '192.168.7.2' ipv4.dns '8.8.8.8'# 使更改生效nmcli c up ens33 其中： 在 nmcli 中，很多关键字都支持缩写，c 是 connection 的缩写，mod 是 modify 的缩写，d 是 device 的缩写。 并不是每一个连接都要配置 DNS，因为默认情况下，有一个系统默认的全局 DNS（/etc/resolve.conf）。只有当你需要为这个连接指定特别的 DNS 时才需要配置。 ipv4.addr 等属性列表，可以通过命令 nmcli c show ens33 查看，然后根据自己的需要进行修改。 创建连接1234# 创建连接nmcli c add type ethernet ifname ens33 con-name eth0 ipv4.method 'manual' ipv4.addr '192.168.7.11/24' ipv4.gateway '192.168.7.2'# 激活（切换）连接nmcli c up eth0 其中： type ethernet 指定连接类型 ifname ens33 指定对应的设备名 con-name eth0 指定连接名，可以忽略，此时会自动生成连接名 ipv4.method 等后续配置，可以在创建时就指定，也可以创建好链接后，再修改 eth0 激活后，之前的 ens33 连接会变为非活跃状态 设备是否（例如开机）自动连接可以通过 nmcli d set &lt;ifname&gt; [autoconnect yes|no] [managed yes|no] 来配置 多个 IP虽然一个设备只能有一个激活的连接，但这不代表只能有一个 IP，我们可以通过以下方式添加多个 IP 单连接多 IP12nmcli c mod eth0 +ipv4.addr '192.168.7.12/24'nmcli c up eth0 注意，ipv4.addr 前面有一个 + 表示追加，对应的，还可以使用 - 表示移除，而无符号则表示覆盖 桥接123456# 添加桥接连接nmcli c add type bridge ifname eth1 con-name eth1# 配置 IPnmcli c mod eth1 ipv4.method 'manual' ipv4.addr '172.16.1.10/16' ipv4.gateway '172.16.0.2'# 激活nmcli c up eth1 其中： type bridge 表示添加一个桥接连接，同时它会自动创建一个桥接设备，形成逻辑上的两个设备，这样我们就可以同时有两个活跃的连接 其它-hnmcli 拥有很完整的帮助文档，在使用时你可以经常加上 -h 查看。简单来讲，主要就是 connection 和 device 对象的增删改查。 命令补全nmcli 不仅支持命令缩写，还支持 tab 命令补全，前提是安装 bash-completion，可以通过如下命令安装它： 1dnf install -y bash-completion 完成后，重新登录一下即可。 参考链接基于RHEL8/CentOS8的网络IP配置详解 使用 NETWORKMANAGER 命令行工具 NMCLI （由 RedHat 提供的文档，并且提供了中文版）","link":"/2020/08/25/network-manager/"},{"title":"alias 使用","text":"一个简单实用的命令，通过 alias 命令设置一个别名，比如 alias c='clear' 可以让输入 c 与 clear 的效果是相同的。 alias 的用法非常简单： 1$ alias 别名='原命令 -选项/参数' alias 命令有两种使用方式，在命令行中直接使用、将命令写入至 bashrc 文件，而写入 bashrc 文件又分为写入用户文件和系统文件。 命令中行使用1$ alias cdgo='cd /go/src/github.com/3ks/3ks.dev' alias 会立即生效，但只会在本次会话生效，对于其它会话（包括其他用户、该用户的其它会话）都无效。 写入用户 bashrc 文件将 alias 写入用户 bashrc 文件可以带来永久的效果，这些 alias 对该用户有效，该文件位于 ~/.bashrc： ~/.bashrc1$ alias cdgo='cd /go/src/github.com' 保存退出后，执行下面的命令使之生效： 1source ~/.bashrc 写入系统 bashrc 文件将 alias 写入系统 bashrc 文件可以带来永久的效果，这些 alias 对系统中的所有用户有效，该文件位于 /etc/bashrc： /etc/bashrc1$ alias cdgo='cd /go' 保存退出后，执行下面的命令使之生效： 1source ~/.bashrc alias 优先级对于存在冲突的 alias，命令行优先于用户 bashrc 文件优先于系统 bashrc 文件 参考链接alias命令","link":"/2020/08/26/alias/"},{"title":"各种简写及其含义","text":"一些简写的全写及其含义。 目的在 GitHub 的开源项目中与他们协作时，会用到大量的缩写字母。 这并不是什么高大上的东西，甚至说有点土。不信？来看几个例子 gkd、dbq、xjj、xgg ，什么意思呢？其实这种汉语拼音的首字母缩写，意思是 搞快点、对不起、小姐姐、小哥哥。是不是瞬间觉得很土了！听说现在的 00 后们很喜欢这种 缩写体 聊天方式。 什么，你接受不了？不管你是 70 后、80 后还是 90 后。gg、mm、886、520 总用过吧！当年 40 后、50 后、60 后也受不了你们！ 这些简写字母其实是各种短语的 首字母 或 首字母谐音 缩写，目的是为了方便多人协作和交流。 其实我认为这些缩写本质上来说，是一种简单高效的交流方式，只是需要花点时间去学习，了解其含义。 本文会介绍英文中的一些单词首字母缩写及其含义，主要分为三类，英文单词缩写、汉语拼音缩写和开源协作类缩写。 其中开源协作类的内容会稍微复杂一点，主要面向 开发者 人群做介绍，因为其可能不仅仅是表达某种意思，还会被 机器人 视为 指令 并做一些自动化处理，所以还会介绍其作用，以及在什么哪一个仓库有效。既然说到了自动化处理，还会介绍一些其它的非缩写的 指令。好吧，其实我主要是想说的 Kubernetes 相关的仓库。 英文单词缩写体老美们懒惰腐败的交流方式： 缩写 原文 含义 R U OK? are you ok? 你还好吗？ NG no good 不够好（一般指导演认为不够好，需要重拍） GG good game 一局精彩的游戏 NGG no good game 这不是一局精彩的游戏 bashrc bash run command bashrc 一般是某个文件，在一个新建 bash 开始时，会执行 bashrc 中的命令，可以将其看成一个初始化脚本 汉语拼音缩写体深受小鲜肉们喜爱的聊天交流方式。 缩写 原文 出处 awsl 阿伟死了 - xswl 笑死我了 - gkd 搞快点 - 开源协作类这一部分的前 3 列 非开发者 人群也可以阅读，本质上还是一些英文缩写，可以了解一下 程序员 们是如何进行全球协作开发的。 一般的指令都会 @someone 某个人，这跟你在微博上 @某个人 是一样的意思。 后面几列专业性稍强，主要面向 程序员 做介绍。 这一部分的内容会有缩写、缩写指令、非缩写指令三种类型，主要介绍在 Kubernetes 系的开源仓库中协作时会用到的一些缩写。 缩写 原文 含义 k8s bot 动作 /cc @someone see see 看看（请帮我 review 一下代码） 自动将你 @ 的人添加至 reviewer 列表，表示你希望此人帮你 review 代码。 /cc @someone see see 看看（请帮我 review 一下代码） 自动将你 @ 的人添加至 reviewer 列表，表示你希望此人帮你 review 代码。 LTLR Too Long To Read 内容很长警告！ - GA General Availability 一般指某软件的首个可用版本 - 参考链接聊天字母缩写曝光：你对00后的世界一无所知","link":"/2020/08/26/argot/"},{"title":"个人常用的 docker-compose 配置文件","text":"在平时做各种小实验时，通过 docker-compose 可以快速的搭建一个环境，记录一下自己用到的一些清单 习惯 根目录是 /cs （containers） 为每个项目创建一个目录，存放其相关的资源文件、docker-compose.yaml 等 Mysqldocker-compose.yaml123456789101112version : '2'services : mysql : image : mysql:latest container_name : mysql8 ports : - \"3306:3306\" volumes : - \"/cs/mysql/data:/var/lib/mysql\" environment : MYSQL_ROOT_PASSWORD : password123 restart : always Redisdocker-compose.yaml1234567891011version : \"2\"services : redis : image : redis:latest container_name : redis volumes : - /cs/redis/data:/data ports : - \"6379:6379\" restart : \"always\" entrypoint : redis-server --requirepass \"password123\" FTPdocker-compose.yaml1234567891011121314151617version: '2'services: ftpd_server: image: stilliard/pure-ftpd:hardened container_name: pure-ftpd ports: - \"21:21\" - \"30000-30009:30000-30009\" volumes: - \"/images/ftp/data:/home/guan/\" - \"/images/ftp/passwd:/etc/pure-ftpd/passwd\" environment: PUBLICHOST: \"192.168.1.90\" FTP_USER_NAME: guan FTP_USER_PASS: mypass FTP_USER_HOME: /home/guan restart: always 如果连接卡在读取目录列表可以参考 FileZilla 读取目录列表失败的解决办法 ftp Nginxdocker-compose.yaml123456789101112version: '2'services: nginx-server: image: nginx:latest container_name: nginx-server ports: - \"80:80\" volumes: - \"/cs/nginx/html:/usr/share/nginx/html\" - \"/cs/nginx/nginx.conf:/etc/nginx/nginx.conf\" - \"/cs/nginx/log:/var/log/nginx\" restart: always 你还需要准备静态文件，并将其放到 /cs/nginx/html/ 下 你还需要准备 nginx 的配置文件，其绝对路径为 /cs/ngix/nginx.conf 这是一个 nginx.conf 的示例： nginx.conf1234567891011121314151617181920212223242526272829user nginx;worker_processes 1;error_log /var/log/nginx/error.log warn;pid /var/run/nginx.pid;events { worker_connections 1024;}http { include /etc/nginx/mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] &quot;$request&quot; ' '$status $body_bytes_sent &quot;$http_referer&quot; ' '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;'; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; include /etc/nginx/conf.d/*.conf;} Postgresqldocker-compose.yaml1234567891011version : \"2\"services : postgres : image : \"postgres:latest\" container_name : \"postgres\" ports : - \"5432:5432\" volumes : - \"/cs/postgres/data:/var/lib/postgresql/data\" environment : POSTGRES_PASSWORD : \"mypassword\" TODO参考连接mac或者linux通过docker管理nginx部署静态文件 nginx 403 forbidden 二种原因 postgres postgresql数据库改变data目录 Docker上部署FTP服务器（基于stilliard/pure-ftpd）","link":"/2020/08/26/common-docker-compose/"},{"title":"fork 炸弹","text":"偶然看到一串奇怪的命令，手贱执行了一下，没想到系统直接卡死 代码1alias clear=':(){ :|: &amp;};:' 一次偶然的机会，我看到了上面这段代码，然后手贱执行了一下： 1:(){ :|: &amp;};: 电脑直接就卡死了，过了几分钟，我才回过神来，是这段代码导致的。 网上搜了一下，这段代码就是著名的 fork bomb 即 fork 炸弹，其会以指数级的速度快速创建线程，迅速将整个系统的资源耗尽，最终导致系统卡死。 fork 炸弹一旦引爆，基本只能重启。 代码解析最开是看到这段代码一脸懵逼，怎么就卡死了呢，网上搜了一下，大致了解了其工作流程。 在这一行代码中，我们定义了一个名为 : 的函数： 1:(){ :|: &amp;};: 把 : 换成一个常见的函数名，比如 bomb，那么上面这段代码可以翻译为： 1bomb(){ bomb|bomb &amp;};bomb 再展开一下： 1234bomb(){ bomb|bomb &amp;};bomb 这样看起来就直观多了，前三行定义了一个函数，第四行调用了该函数。 而函数的行为是：后台的、通过管道递归调用自身两次 由于管道操作会创建新的进程，所以每次调用函数都会产生两份拷贝，这样函数就会呈指数级的增长，可以在极短的时间内耗光计算机资源。 参考链接fork 炸弹","link":"/2020/08/26/fork-bomb/"},{"title":"在 Centos 8 上安装 Docker","text":"一个安装 Docker 的笔记 手动安装 containerd.io1Problem: package docker-ce-3:19.03.4-3.el7.x86_64 requires containerd.io &gt;= 1.2.2-3 如果你收到类似上面这种提示，则需要手动安装 containerd.io 目前 docker 版本已经来到 19+，其对组件 containerd.io 的要求是 &gt;= 1.2.2-3，由于 Centos 软件源更新不及时（后续版本更新后这个问题可能就不存在了），默认源下没有符合要求的版本，所以该组件无法完成安装，这里我们需要手动安装 containerd.io 安装通过阿里云镜像安装： 1dnf install https://mirrors.aliyun.com/docker-ce/linux/centos/7/x86_64/stable/Packages/containerd.io-1.2.6-3.3.el7.x86_64.rpm 如果你的服务器在国外，或者网络足够好的化，也可以直接从 docker 官方下载安装： 1dnf install https://download.docker.com/linux/centos/7/x86_64/stable/Packages/containerd.io-1.2.6-3.3.el7.x86_64.rpm 此外，上面的命令中的 rpm 包可能随着时间的推移而变得陈久，但你可以直接访问 Docker 官方 或者 阿里云镜像 查看并选择最新的 rpm 包。 安装 Docker添加仓库添加 Docker 官方的仓库信息： 12$ sudo yum install -y yum-utils$ sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo 安装正常的 Docker 安装： 1$ sudo yum install docker-ce docker-ce-cli 启动并添加开机启动项1$ sudo systemctl enable --now docker 验证1$ sudo docker run hello-world 等待镜像启动完成后，如果你可以看到的内容类似于下面这样，则表示安装成功： 12345678910111213141516171819202122$ sudo docker run hello-worldHello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal.To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bashShare images, automate workflows, and more with a free Docker ID: https://hub.docker.com/For more examples and ideas, visit: https://docs.docker.com/get-started/ 镜像加速由于网络方面的原因，我们在拉取镜像的时候速度可能会很慢，对此，我们可以通过编辑配置文件，配置镜像来加快其速度。 在 Linux 系统中，默认情况下，Docker 的配置文件是 /etc/docker/daemon.json（Configure the Docker daemon） /etc/docker/daemon.json123{ \"registry-mirrors\": [\"http://hub-mirror.c.163.com\"]} 配置好镜像后，你需要执行以下命令： 12$ systemctl daemon-reload $ systemctl restart docker 安装 Docker Compose12$ sudo curl -L \"https://github.com/docker/compose/releases/download/1.26.2/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose$ sudo chmod +x /usr/local/bin/docker-compose 随后，你可以运行下面的命令查看 Docker Compose 版本，并以此判断是否安装成功： 12$ docker-compose -vdocker-compose version 1.26.2, build eefe0d31 Docker Compose 可用于单机简单的编排，在学习、测试时是一个不错的选择。对于更加复杂的容器编排，唯一的选择是 Kubernetes 卸载卸载 Docker Compose1sudo rm /usr/local/bin/docker-compose 卸载 Docker1$ sudo yum remove docker-ce docker-ce-cli containerd.io 但是，相关的镜像、容器、卷以及其它自定义目录下的内容不会被自动删除，你需要自己手动删除它们： 123$ sudo rm -rf /var/lib/docker# 删除其它自定义目录$ sudo rm -rf ... 参考链接Install Docker Engine on CentOS CentOS之——CentOS8 安装 Docker Install Docker Compose","link":"/2020/08/26/install-docker-on-centos-8/"},{"title":"docker 的一些操作","text":"在使用 docker 时的一点及其，本质上来讲学好 linux 的命令，用任何软件都很简单。 筛选镜像docker imagedocker image 的输出类似于这样，如果要批量操作镜像，我们一般会选择镜像名：tag 或者 IMAGE ID 的方式进行批量操作 1234$ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEalpine 3.10.4 af341ccd2df8 2 months ago 5.56MBredis 5.0.5-alpine ed7d2ff5a623 7 months ago 29.3MB 筛选镜像keyword 表示镜像关键字，可以是镜像名、Tag、ID、体积等，总之是某个关键字，如果为 . 则匹配所有镜像： 1$ docker images | grep \"keyword\" 列出镜像按镜像名列出1$ docker images | grep \"keyword\" | sed '1d' | awk '{print $1}' 按镜像名：tag列出1$ docker images | grep \"keyword\" | sed '1d' | awk '{print $1\":\"$2}' 按 IMAGE ID 列出1docker images | grep \"keyword\" | awk '{print $3}' 批量操作批量导出镜像按照 镜像名：Tag 的风格导出，以便在其它地方导入后可以方便的识别镜像名称 执行下面这条命令即可将所有包含关键字的镜像导出为单个文件 all.tar.gz 1IMAGES_LIST=($(docker images | grep \"keyword\" | sed '1d' | awk '{print $1\":\"$2}')) &amp;&amp; docker save ${IMAGES_LIST[*]} -o all.tar.gz 批量导入镜像获取到一个镜像包后，（例如上面导出的 all.tar.gz ），执行 docker load &lt; 包名 即可将包内的所有镜像导入至本机： 1docker load &lt; all.tar.gz 批量删除镜像1docker rmi $(docker images | grep \"keyword\" | awk '{print $3}') 或者 1docker rmi -f $(docker images | grep \"keyword\" | awk '{print $3}') 如果遇到多个镜像拥有相同的 IMAGE ID，在第二种方式中，会强制删除所有所有与 IMAGE ID 匹配的镜像，而不论其他镜像是否与 keyword 匹配。 第一种方式则不会删除这种镜像 参考链接逐个和批量导出导入docker镜像 docker 如何批量删除镜像","link":"/2020/08/27/docker-opreation/"},{"title":"一些混乱的草稿","text":"记录了各种各样的内容，暂时没有想好为其单独开一篇博客，先放在这儿吧 为什么 cp -f 依然提示是否覆盖linux cp拷贝覆盖不提示 如何给网页指定 favicon设置favicon的几种方式 如何给谷歌云新建的 VM 实例设置 root 密码谷歌云开启SSH及设置root密码 如何修改 Centos 的 hostname1$ hostnamectl set-hostname &lt;your-hostname&gt; 修改后立即生效，但需要重新登录 shell，才能看到效果 参考：centos修改主机名的正确方法 意外断电导致 CentOS 异常解决方式与 VMWare的CentOS虚拟机断电或强制关机出现问题 一致 修改时区CentOS7 开始引入了一个 timedatectl 工具，直接运行命令： 1$ timedatectl set-timezone Asia/Shanghai 也可以手动修改时区文件： 1$ cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime 如果设置时区后，时间依然快了 8 小时,可以执行下面的命令： 1$ ln -s -f /usr/share/zoneinfo/Universal /etc/localtime 参考： CentOS 7 修改系统默认时区 CentOS 7系统时间与实际时间差8个小时 ifconfig command not found1$ dnf install -y net-tools 关闭 SELinux临时关闭： 1$ setenforce 0 永久关闭： 编辑 /etc/selinux/config 文件，将 SELINUX 项的值修改为 disabled /etc/selinux/config123456# This file controls the state of SELinux on the system.# SELINUX= can take one of these three values:# enforcing - SELinux security policy is enforced.# permissive - SELinux prints warnings instead of enforcing.# disabled - No SELinux policy is loaded.SELINUX=disabled 参考：查看 SELinux状态及关闭SELinux 黑苹果安装提要 硬件选择，选对硬件就成功了一半。 镜像下载，去远景论坛看看最新的镜像，也可以去自己的云盘找找库存 制作启动盘，关键软件 transMac。制作完成后，根据硬件选择合适的 config.list 文件 安装系统，排错，谷歌，爬论坛 安装软件，调整 putty 的一些使用问题由不正确的配置导致在 putty 中回退、方向键等乱码问题，按下图箭头所指设置即可： 小键盘等乱码问题，按下图设置箭头所指设置即可： 设置完记得保存 session","link":"/2020/08/27/draft/"},{"title":"使用 firewall-cmd 命令管理防火墙","text":"Linux 的新防火墙软件，跟 iptables 差不多的工具。firewall-cmd 是 firewalld 的 cli 管理工具，firewalld 是centos7 的一大特性，最大的好处有两个：支持动态更新，不用重启服务；第二个就是加入了防火墙的 zone 概念。 管理命令查询 zone 与 接口信息123$ firewall-cmd --get-active-zonespublic interfaces: ens33 该命令会列出各接口所属的 zone，默认情况下，接口都在 public 下，public 也是模式 zone 重新加载防火墙规则1$ firewall-cmd --reload 在修改防火墙规则后，通过该命令使规则生效 规则管理查看开放端口情况1$ firewall-cmd --zone=public --list-ports 查看指定 zone 下开放的端口列表，如果未指定 zone 则查看默认 zone。 主要注意的是： 永久改动的规则，在 reload 之前不会生效，此时也不会被列出； 临时改动的规则，会立即生效，在 reload 之后失效； 开放端口端口的语法是： 1&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt; 即指定一个 IP 或 IP 范围，以及协议。常见的协议是 TCP、UDP 例如： 1238080/tcp8081/udp8082-8085/tcp 示例： 123456$ firewall-cmd --add-port=8080/tcpsuccess # 添加成功反馈$ firewall-cmd --add-port=8081/udp --zone=publicsuccess # 添加成功反馈$ firewall-cmd --add-port=8082-8085/tcp --zone=public --permanentsuccess # 添加成功反馈 没有指定 zone 的规则，自动使用默认 zone 带有参数 --permanent 的规则是永久生效的，不会在重启后失效 规则修改完成后，不要忘记重新加载规则，使其生效 禁用端口默认情况下下，未开启端口即视为禁用，对于已经开放的端口，我们可以移除相关规则，使其被禁用。 禁用端口的关键字是 --remove-port，其用法与 ---add-port 类似。 示例： 1234567891011121314$ firewall-cmd --remove-port=8080/tcpsuccess # 禁用成功反馈$ firewall-cmd --remove-port=8081/udp --zone=publicsuccess # 禁用成功反馈$ firewall-cmd --remove-port=8082-8100/tcp --zone=public --permanentWarning: NOT_ENABLED: 8082-8100:tcpsuccess$ firewall-cmd --remove-port=8083/tcp --zone=public --permanentWarning: NOT_ENABLED: 8083:tcpsuccess$ firewall-cmd --reload # 重新加载规则success$ firewall-cmd --list-port # 禁用没有生效8082-8085/tcp 需要注意的是，开放与禁用一条规则，涉及的端口写法需要完全一致。 我们前面开放的是 8082-8085/tcp 端口，这里禁用的是 8082-8100/tcp 以及 8083/tcp，此时会有成功反馈，但也有一个警告提示我们：这些端口本就没有开放。重新加载规则列表，8082-8085/tcp 依然在列表内，说明这些端口依然是可用的。 想要移除该规则，需要 --remove-port=8082-8085/tcp： 12345$ firewall-cmd --remove-port=8082-8085/tcp --permanentsuccess$ firewall-cmd --reloadsuccess$ firewall-cmd --list-port 这一条防火墙规则算是正确删掉了 参考链接Linux firewall-cmd 命令详解","link":"/2020/08/27/firewall/"},{"title":"windows 下的常见软件提要","text":"虽然我每次装完系统，都会给系统做备份，但这个备份我是从来不用，因为我总是喜欢装最新版本的操作系统，并且也记不清对以前备份的系统做了些什么，然后每次装个新系统老是要想半天这次又要装些什么软件呢？所以这个文章就诞生了，记录一下我对一个纯净的操作系统做了些什么~ 内容可能会根据工作的内容的变化而变化。 Windows10:Latest 可以在 d:/iamges/ 下找到安装镜像，也可以前往 https://msdn.itellyou.cn/ 查看是否有新版本发布。 安装完系统后，首先卸载掉一堆不需要的 Win10 自带应用 鲁大师 ，安装驱动。 如果网络不方便，请前往 d:/soft/1-base/ 安装历史版本 如果网卡不能免驱，请前往 d:/soft/1-base/ 安装驱动精灵万能网卡版 常用软件下述软件如果没有没有提供下载链接，或者下载链接失效，无法访问下载链接，请直接前往 d:/soft/1-base 使用安装包安装。 ShadowSockesR SSTap WinRarX64 Or WinRarX86 IDM BitComet Chrome DISM++ 网易云音乐 QQ 音乐 有道词典 Potplayer PanDownload TIM Office365 MPic 可选软件下述软件如果没有没有提供下载链接，或者下载链接失效，无法访问下载链接，请直接前往 d:/soft/2-option 使用安装包安装。 FireFox 迅雷X MacType G302 Driver Cpu-z Gpu-z Steam OBS 三星固态硬盘管理软件 Foxmail 通用开发工具下述软件如果没有没有提供下载链接，或者下载链接失效，无法访问下载链接，请直接前往 d:/soft/3-common 使用安装包安装。 VMware15 Navicat Putty Redis Desktop Manager 这个下载好像有点麻烦，考虑本地安装包或者换一个？ NotePad++ Git GitKraken PostMan Go下述软件如果没有没有提供下载链接，或者下载链接失效，无法访问下载链接，请直接前往d:/soft/4-go使用安装包安装。 Go SDK Goland 小工具登录 OneDriver，tools 目录下的一些常用小软件： PicGo ScreenToGif WSL访问 Microsoft Store，安装 Ubuntu，在某些场景下有用 清理用 Dism++ 完成个性化设置，并清理文件","link":"/2020/08/27/init-windows/"},{"title":"PicGo 新的图床工具","text":"之前一直使用的图床工具是 MPic，虽然软件长期没有更新，但对我来说，MPic 足够的简单易用，并且是绿色软件，点开即用，使其看起来更加的轻量。 但是最近我发现 MPic 的官网已经打不开了，这意味着其提供的 预览和管理图片 功能无法再使用，因此，我不得不重新寻找一款新的图床工具。 PicGo通过谷歌搜索 图床工具 可以很轻松的找到一系列的图床工具，其中 PicGo 引起了我的注意，这款工具的名称风格让我以为它是使用 Go 语言开发的。 显然我是想太多了，PicGo 是基于 Electron-vue 构建并开源的，不过 PicGo 看起来还是很不错的，它拥有很多的优点，特别是这三点： 支持 Windows, macOS, Linux。 支持 快捷键上传 剪切板里的第一张图片，且快捷键可以根据自己的习惯修改。 上传图片后 自动复制链接 到剪切板，且支持多种风格的链接（html、markdown、自定义风格等）。 基于这三点，PicGo 上传图片的操作异常简单：Ctrl + C（或者截图）-&gt; 上传快捷键 -&gt; Ctrl + V。然后我就可以得到一个 markdown 的图片链接。整个过程是如此的简单而灵活，必需给作者一个赞。 使用方式这里简单记录一下 Windows 平台下，使用 PicGo 作为图床工具，管理七牛云对象的过程。 下载并安装 PicGo前往 https://github.com/Molunerfinn/PicGo/releases 根据自己的平台，选择下载最新的稳定版即可。如果你想尝鲜，也可以选择 Beta 版。 然后双击安装程序，下一步，完成安装即可，没啥好说的。 图床配置显示图床 PicGo 支持多种图床，而我目前只使用七牛云，对于其它用不到的图床，可以在 PicGo 设置界面将其隐藏： 填写图床信息 这些配置项都取决于你自己的实际情况，如果你不清楚相关配置项应该如何填写的话，可以搜索一下入门文章或者七牛云官方文档。 一个坑对于使用七牛云的同学，在设置图床时，访问地址 记得填上 http:// 或者 https://。 虽然不填不会报错，图片也能正确上传，但这会影响到生成的链接和图片预览。 如果去掉访问地址的 https://，此时生成的图片链接会是这样：![name](cdn.sguan.top/makrdown/20200504174627.png)，虽然图片已经上传成功，但这个地址很多 markdown 渲染器是无法正确渲染的，需要我们手动加上 https://。 并且图片预览界面也会异常，无法正常显示这种图片。 总结 MPic 相较于 PicGo 唯一的优点可能就是轻量，无需安装即可使用，其它的我个人觉得 PicGo 完胜。 PicGo 支持插件，且拥有不错的生态，我对其未来充满信心，至少不会轻易跑路，遇到问题也方便寻求帮助（事实上，上面那个坑的解决方法就是在 PicGo 仓库的 issue 中找到的）。 Mac 版的 GUI 比较漂亮，有毛玻璃效果，而 Windows 版就一言难尽了，相比之下比较难看。 PicGo 是一款简洁而强大的图床工具。 参考链接PicGo。 上传图片后就看不到图片了","link":"/2020/08/27/new-image-host/"},{"title":"windows 下端口被占用的问题","text":"在windows平台下启动某个软件，有时候会出现如下错误，提示端口已经被占用。 找到占用端口的程序，并杀掉该程序打开 cmd 命令行，执行： 1$ netstat -aon|findstr \"1080\" 其中 1080 为要想排查的端口号 再输出结果中，其中最后一列表示程序 PID，打开任务管理器，找到 PID 对应的程序关闭即可。 如果任务管理内没有 PID 这一列，可以右键字段列表，勾选 PID 即可 无法找到占用端口的程序有些情况下，通过上面的命令找不到任何占用该端口的程序，但运行软件依然会提示端口已被占用。 此时需要以管理员身份打开命令行，然后运行下面的命令： 1$ netsh winsock reset 随后重启计算机即可 参考链接关于端口被占用而又找不到被占用的程序的解决办法","link":"/2020/08/27/port-used/"},{"title":"SSH 之免密登录","text":"SSH 免密登录以及一些问题的笔记 生成密钥对在服务器上生成用于登录的公钥和私钥，最终公钥放于服务器，私钥自己保存使用。 1$ ssh-keygen -t rsa 首先提示输入生成文件的输出路径，然后是密码，最后是确认密码 密码是用于加密和登录时输入的密码，额，建议为空，不然还叫免密登录吗，但是请确保生成证书的安全，证书泄露可能很危险 生产环境强烈建议设置密码，毕竟稳定压倒一切,相当于双重验证吧，需要提供私钥，还要提供密码 导入公钥1$ cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys 配置文件、文件夹的权限123$ sudo chmod -R 0700 ~/.ssh$ sudo chmod -R 0600 ~/.ssh/authorized_keys$ sudo chown -R guan:guan /home/guan # guan 替换为自己的用户名 SELinux如果启用了 SELinux，还需要执行（root 用户把 /home 改成 /root） 1$ restorecon -R -v /home 修改 SSH 配置文件修改 SSH 配置文件，支持使用证书登录，修改该文件需要 root 权限。 在 /etc/ssh/sshd_config 文件末尾追加以下内容： /etc/ssh/sshd_config查看源文件12345RSAAuthentication yes #RSA验证方式StrictModes yes #严格模式，会检查相关目录的权限,根据自己情况选择PubkeyAuthentication yes #允许用户使用自己生成的公私钥AuthorizedKeysFile .ssh/authorized_keys #公钥地址PasswordAuthentication no #是否允许通过密码登录 随后重启 SSH 服务： 1systemctl restart sshd 获取私钥在要使用 SSH 登录的客户端在，获取到私钥，可以使用 scp 或者其它方式： 1$ scp guan@192.168.1.2:~/.ssh/rsa ./ 需要注意的是，在 windows 环境下，不要直接复制粘贴密钥对，这会使其失效。 前面修改了 SSH 配置，并且你恰好禁止的密码登录，此时你可能无法顺利拿到私钥，即： /etc/ssh/sshd_config查看源文件1PasswordAuthentication no #是否允许通过密码登录 你可以先将这一项改为 yes，后续再修改回来。 使用私钥拿到私钥后，不同的客户端使用私钥的方式有所不同，不过其原理都是相同的。 PuTTY生成证书可以使用 PuTTY Key Generator 生成适用于 Putty 的证书 选中私钥文件，然后点击保存为私钥 Save private key 使用证书 打开Putty，加载或者新建一个会话 点击 connection-&gt;data , 输入 Auto-login username (自动登录的用户名) connection-&gt;ssh-&gt;auth 在Private key file for authentication选择私钥文件 保存会话，然后直接点击会话即可免密登录 sh对于各种 shell 环境，直接将私钥复制到 ~/.ssh/ 下，命名为 id_rsa 即可。 1$ cp id_rsa ~/.ssh/id_rsa 然后便可以直接进行 ssh 登录： 1$ ssh guan@192.168.1.2 公钥部署到多个服务器再提醒一下，客户端使用私钥，服务端使用公钥。 将一份公钥部署到多个服务器，并正确配置，可以使用实现一份私钥免密登录到多个服务器上。当然这相当于将鸡蛋都装到了一个篮子里，安全风险也更大一些。 我们可以直接在多个服务器之间使用 scp 传输公钥： 1ssh user@host 'mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys' &lt; ~/.ssh/id_rsa.pub 需要注意的是，不要直接复制粘贴公钥，很可能出错，导致服务器拒绝登录，特别是 windows 环境下 SSH 登录慢的问题原因OpenSSH 在用户登录的时候会验证 IP，它根据用户的 IP 使用反向 DNS 找到主机名，再使用 DNS 找到 IP 地址，最后匹配一下登录的 IP 是否合法。如果客户机的 IP 没有域名，或者 DNS 服务器很慢或不通，会一直等到DNS超时，SSH 登录慢就体现在这里。 解决方法修改 ssh 的配置文件，关闭 DNS 和 GSSAPI 验证即可加快登陆速度。 编辑 OpenSSH 的主配置文件 /etc/ssh/sshd_config，在文件末尾追加下面的内容： /etc/ssh/sshd_config12GSSAPIAuthentication noUseDNS no 然后重启 SSH 服务，再尝试登录测试一下是否有效。 1$ systemctl restart sshd 再尝试登录测试一下是否有效。 参考链接CentOS 7 SSH使用证书登录 Putty server refused our key的三种原因和解决方法 SSH原理与运用（一）：远程登录","link":"/2020/08/27/ssh-auth/"}],"tags":[{"name":"GitHub","slug":"GitHub","link":"/tags/GitHub/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"CentOS","slug":"CentOS","link":"/tags/CentOS/"},{"name":"cache","slug":"cache","link":"/tags/cache/"},{"name":"swap","slug":"swap","link":"/tags/swap/"},{"name":"Badge","slug":"Badge","link":"/tags/Badge/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"icarus","slug":"icarus","link":"/tags/icarus/"},{"name":"CDN","slug":"CDN","link":"/tags/CDN/"},{"name":"GitHub Page","slug":"GitHub-Page","link":"/tags/GitHub-Page/"},{"name":"GitHub Action","slug":"GitHub-Action","link":"/tags/GitHub-Action/"},{"name":"go","slug":"go","link":"/tags/go/"},{"name":"todo","slug":"todo","link":"/tags/todo/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"mysql 8.0","slug":"mysql-8-0","link":"/tags/mysql-8-0/"},{"name":"NetworkManager","slug":"NetworkManager","link":"/tags/NetworkManager/"},{"name":"NM","slug":"NM","link":"/tags/NM/"},{"name":"command","slug":"command","link":"/tags/command/"},{"name":"alias","slug":"alias","link":"/tags/alias/"},{"name":"argot","slug":"argot","link":"/tags/argot/"},{"name":"黑话","slug":"黑话","link":"/tags/%E9%BB%91%E8%AF%9D/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"docker-compose","slug":"docker-compose","link":"/tags/docker-compose/"},{"name":"security","slug":"security","link":"/tags/security/"},{"name":"fork bomb","slug":"fork-bomb","link":"/tags/fork-bomb/"},{"name":"centos8","slug":"centos8","link":"/tags/centos8/"},{"name":"draft","slug":"draft","link":"/tags/draft/"},{"name":"windows","slug":"windows","link":"/tags/windows/"},{"name":"PicGo","slug":"PicGo","link":"/tags/PicGo/"},{"name":"port","slug":"port","link":"/tags/port/"},{"name":"ssh","slug":"ssh","link":"/tags/ssh/"}],"categories":[{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"Github","slug":"Github","link":"/categories/Github/"},{"name":"CentOS","slug":"Linux/CentOS","link":"/categories/Linux/CentOS/"},{"name":"blog","slug":"blog","link":"/categories/blog/"},{"name":"go","slug":"go","link":"/categories/go/"},{"name":"todo","slug":"todo","link":"/categories/todo/"},{"name":"database","slug":"database","link":"/categories/database/"},{"name":"Badge","slug":"Github/Badge","link":"/categories/Github/Badge/"},{"name":"network","slug":"network","link":"/categories/network/"},{"name":"command","slug":"command","link":"/categories/command/"},{"name":"argot","slug":"argot","link":"/categories/argot/"},{"name":"cache","slug":"Linux/CentOS/cache","link":"/categories/Linux/CentOS/cache/"},{"name":"docker","slug":"docker","link":"/categories/docker/"},{"name":"security","slug":"security","link":"/categories/security/"},{"name":"hexo","slug":"blog/hexo","link":"/categories/blog/hexo/"},{"name":"the-way-to-go","slug":"go/the-way-to-go","link":"/categories/go/the-way-to-go/"},{"name":"draft","slug":"draft","link":"/categories/draft/"},{"name":"swap","slug":"Linux/CentOS/swap","link":"/categories/Linux/CentOS/swap/"},{"name":"windows","slug":"windows","link":"/categories/windows/"},{"name":"PicGo","slug":"PicGo","link":"/categories/PicGo/"},{"name":"ssh","slug":"ssh","link":"/categories/ssh/"},{"name":"mysql","slug":"database/mysql","link":"/categories/database/mysql/"},{"name":"NetworkManager","slug":"network/NetworkManager","link":"/categories/network/NetworkManager/"},{"name":"alias","slug":"command/alias","link":"/categories/command/alias/"},{"name":"docker-compose","slug":"docker/docker-compose","link":"/categories/docker/docker-compose/"},{"name":"icarus","slug":"blog/hexo/icarus","link":"/categories/blog/hexo/icarus/"},{"name":"install","slug":"windows/install","link":"/categories/windows/install/"}]}