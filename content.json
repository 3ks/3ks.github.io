{"pages":[{"title":"","text":"找不到这个奇怪的链接！点击返回首页","link":"/404.html"},{"title":"欢迎访问","text":"您好，欢迎访问我的博客。 博客说明一个没什么技术含量的、充满的碎碎念的博客，内容大都不成体系，主要是一些自己的学习笔记，不对的地方请多多指教。 静态博客基于 Hexo，使用主题 icarus CDN除 html 文件外，几乎所有的静态文件都通过 CDN 加速。虽然服务器在美国，但访问速度还是不错 GitHub Action基于 GitHub Action 实现 CI/CD，分别部署到了 https://3ks.dev 和 https://3ks.github.io 一个由自己的服务器提供服务，一个由 GitHub Page 托管，其中一个挂掉，也可以访问另一个，两者内容完全一致 我是官余棚，朋友们一般叫我官二、官二代，来自重庆，农民的儿子，一个吃瓜群众 重庆师范大学计算机科学与技术 2019 届毕业生。 职业21 世纪的农民——码农，目前正在寻找上海地区 Golang 或云原生方向的工作。 标签学以致用、强迫症、爱折腾、有思想、爱自由、死肥宅、内向、友善、杠精、专一 爱好宅、肉、美剧、4K/蓝光电影、3C 产品、可口可乐、英雄联盟 开源贡献大部分都是一些没什么技术含量的贡献，但我不认为自己所做的事情没有意义，我把这看作是一个学习、积累的过程 开源组织侥幸混进了一些开源组织，请访问 https://github.com/3ks 查看。 Golang 基础 gobyexample-cn/gobyexample polaris1119/The-Golang-Standard-Library-by-Example unknwon/the-way-to-go_ZH_CN Golang 应用 google/go-github gin-gonic/website go-gorm/gorm.io facebookincubator/ent Golang 及云原生 kubernetes/website istio/istio.io servicemesher/istio-handbook servicemesher/istio-official-translation cloudnativeto/kubebuilder cloudnativeto/envoy 计算机基础 CyC2018/CS-Notes 前端 ppoffice/hexo-theme-icarus 火箭 🚀 chrislgarry/Apollo-11 r-spacex/SpaceX-API 为什么是 3ks我的 GitHub ID 是 3ks，所以就申请了 3ks.dev 域名 为什么是 3ks 呢？很简单，因为短，对于 ID 这种东西，个人认为越短越好（深受 QQ 号荼毒） 并且 3ks 的中文发音与 tks 相同，意为谢谢。同时，谢谢 也是我的口头禅 别问我为什么不用 tks，我是不会告诉你已经被别人占用了的😒 自我评价一个资质平平的普通人 在领略全球顶级的开发者的风采、见识十几岁天才的资质后，我认识到自己：只是一个凭着爱好碰巧进入了这个行业的普通人而已 虽然世界是由天才来改变的，但天才毕竟只是极少数，普通人也有普通人要做的事，普通人也能为世界更美好贡献一份力量 联系方式 邮箱：1@linux.com GitHub：https://github/3ks","link":"/about/index.html"}],"posts":[{"title":"Linux 清理缓存","text":"以下几条命令用于清理不同类型的缓存。 清除页面缓存（PageCache）下面的命令只会清理掉页面缓存，对于生产环境来说是比较安全的。 1$ echo 1 &gt; /proc/sys/vm/drop_caches 清除目录项和 inode1$ echo 2 &gt; /proc/sys/vm/drop_caches 清除页面缓存、目录项和 inode下面的命令会将缓存完全清除，随后可能导致系统变慢，因为很多应用程序的缓存失效后，会从数据源读取数据（例如硬盘、API 等）。 不建议在生成环境用使用该命令，除非你知道自己在做什么： 1$ echo 3 &gt; /proc/sys/vm/drop_caches 注意事项适用场景建议仅在测试和调试场景使用。 清理该文件不应该作为控制内存使用的手段，缓存是由程序申请并使用的，它往往会带来程序效率的提升（如减少磁盘访问频率），内存开销过大一般应该从程序优化角度考虑。如果你强行清理掉缓存，反而可能带来性能损失，因为一些程序在缓存失效后，会消耗大量的 I/O 和 CPU 来重建缓存。 非破坏性的实际上，上面的清除操作都不是破坏性的操作，即它们都不会清除脏对象，因此你不必担心未同步的文件会被清除掉。 但换个角度来看，这在一定程度上会减少清理缓存的效果，因为脏对象没有被清理。 此时我们可以在清除缓存前，执行 sync 命令，先同步文件，减少脏对象的数量，以提高清理效果。例如： 1$ sync; echo 1 &gt; /proc/sys/vm/drop_caches 问题（TODO）虽然到处都在说 1、2、3 分别代表清除不同类型的缓存，但从来没有人说过为什么 echo 不同的数字会带来不同的效果。 其用法在 Kernel Documentation （关键字 drop_caches） 可以找到。但同样只写了用法与效果，没有提到原理。 个人猜测这是 Kernel 拦截了对 drop_caches 文件的写入，并根据不同值做出不同处理 以后有机会再看看… 参考链接在 Linux 上如何清除内存的 Cache、Buffer 和交换空间 Kernel Documentation Hibernate中的脏检查和缓存清理机制","link":"/2020/07/14/clean-cache/"},{"title":"Hello World","text":"欢迎 来到 Hexo! 普通文本Hello World 图片 引用 一个肮脏的国家，如果人人讲规则而不是空谈道德，最终会变成一个有人味儿的正常国家，道德自然会逐渐回归；反之，一个干净的国家，如果人人都不讲规则却大谈道德、谈高尚，天天没事儿就谈道德规范，人人大公无私，最终这个国家会堕落成为一个伪君子遍布的肮脏国家。——沙雕网友 表格 日期 天气 气温 湿度 2020-07-13 晴 33℃ 95% 2020-07-14 阴 28℃ 97% 2020-07-15 小雨 25℃ 99% 纯文本块123Hello WorldWelcome! shell 脚本片段1$ echo \"hello world\" GO 代码main.go查看源文件1234567package mainimport \"fmt\"func main() { fmt.Println(\"hello world\")} JSON 片段1234{\"title\": \"hello world\",\"themes\": \"icarus\"} YAML 片段config.yml12\"title\": \"hello world\"\"themes\": \"icarus\" 一级标题普通文本 二级标题普通文本 三级标题普通文本 四级标题普通文本","link":"/2020/07/14/hello-world/"},{"title":"CentOS 分配和禁用 swap 空间","text":"云服务的内存不够，也没有自动分配 swap 空间，导致 mysql 服务器无法启动。 此时我们可以自己分配 swap 空间作为缓存，个人感觉 swap 类似于 windows 里的虚拟内存。 分配并启用 swap获取硬盘设备路径1$ df -h 分配空间4G1$ sudo dd if=/dev/vda1 of=/swapfile count=4096 bs=1MiB DO 文档里面的 sudo fallocate -l 4G /swapfile 是错误的，评论区出人才！ 权限设置12$ sudo chmod 600 /swapfile$ sudo mkswap /swapfile 制作 swap 系统，如果成功会有一个类似下面的提示： 12Setting up swapspace version 1, size = 4194300 KiBno label, UUID=b99230bb-21af-47bc-8c37-de41129c39bf 启动 swap1$ sudo swapon /swapfile 查看结果1free -m 检查 swap 是否已经在运行、有容量了。 开机自动挂载在文件 /etc/sysctl.conf 末尾追加内容、并保存 /etc/sysctl.conf1/swapfile swap swap sw 0 0 禁用系统默认的 swap 分区某些场景下，不能使用 swap 分区，此时则应该禁用 swap 分区： 取消挂载编辑 /etc/fstab 文件，取消 swap 分区的挂载： /etc/fstab123456789# /etc/fstab# Created by anaconda on Sat Feb 29 05:30:30 2020## Accessible filesystems, by reference, are maintained under '/dev/disk'# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info#/dev/mapper/centos-root / xfs defaults 0 0UUID=666d6259-55da-4501-91fb-40b2c0b16ca2 /boot xfs defaults 0 0/dev/mapper/centos-swap swap swap defaults 0 0 swap 文件系统那一行对应的路径就是目前挂载的 swap 分区。 我们将这一行删掉，或者注释掉，保存退出。 下次系统启动时就不会自动挂载该 swap 分区。 如果不想重启系统，根据 swap 分区的路径，执行下面的命令即可立即禁用 swap 分区。 1$ swapoff /dev/mapper/centos-swap 释放分区todo 参考链接How To Add Swap on CentOS 7 CentOS 7 关闭 swap 分区","link":"/2020/07/14/malloc-swap/"},{"title":"如何为你的 GitHub 项目添加 badge","text":"我们在很多开源项目的 README 都能看到大量的徽章（badge），这些徽章大都挺漂亮的，最重要的是，通过这些徽章，我们可以快速的获取项目的状态信息，例如：开源协议、版本、单元测试覆盖率等。 那我们应该如何为自己的项目加上一些徽章呢？ markdown 与图片markdown 插入图片我们都知道项目的 README 是一个 markdown 文件，在 markdown 内可以这样插入一张图片 1![](https://cdn.sguan.top/markdown/20200721141223.png) 其效果类似于这样： markdown 插入图片链接此外，如果我们想在点击图片后，跳转到某个页面，可以这样写： 1[![](https://cdn.sguan.top/markdown/20200721141223.png)](https://baidu.com) 其效果类似于这样： 点一下图片试试，看看和前一张图片的区别。 shields.io徽章其实也只是一些图片，只不过它看起来会很小，包含了一些信息，并且一般是 svg 格式的。也就是说我们只要在 README.md 中引入这种风格的图片就可以了。 一个徽章的构成元素包括：标签、信息、风格样式： 上面这个徽章，它的标签是 RELEASE，信息是 x.x.x 的一个版本号，风格比较扁平化。 问题在于我们如何生成符合自己需求的图片呢？ 答案是 shields.io，目前我们在 GitHub 上看到的很多徽章都是在这个网站生成的，该网站提供了数以百计的徽章可以选择，并且你还可以自定义徽章，这足以满意绝大部分开发者的需求。生成的图片都会有一个唯一地址，你可以直接引用该图片，或者下载图片，将其保存到项目中，再通过相对目录引用图片。无论如何，我们需要做的只是生成想要的图片、在 markdown 中引入它。 虽然有很多的徽章可以选择，但一般只需要为重要的信息添加徽章，过多的徽章会让读者无法快速提取其中的信息。至于哪些是重要的信息，这取决于具体的项目以及你自身的理解。 静态徽章对一个项目来说，某些徽章基本上不会发生变化，例如：开源协议、一些链接等。 这种徽章可以看成是静态徽章，即不会变化的徽章。 开源协议shields.io 提供了大量的静态徽章，这里我们以 开源协议 系列的徽章为例。 开源协议相关的徽章可以在 这里 看到。 点击你需要的协议，然后填入参数（这里我其实没太明白规则，一般填入 e.g. 后面的字符即可），例如： 红色圈出来的部分就是我们生成的徽章，点击下面的 Copy Badge URL 即可复制徽章图片的地址，得到的地址类似于这样： 1https://img.shields.io/aur/license/android-studio 你也可以点击 ⬇ 展开，复制其它格式的地址，不同格式的地址本质上并没有区别，例如 markdown 格式的徽章地址。 1![AUR license](https://img.shields.io/aur/license/android-studio) 调整风格此外，你可以修改参数，生成不同风格的徽章。 生成的徽章就会是风格比较扁平化的徽章。 自定义徽章如果预置的徽章都不能满足你的要求，你还可以生成自定义徽章。 shields.io 每个页面的底部都提供了自定义徽章的功能，你可以根据自己的需要填入信息、生成徽章、引用。 https://img.shields.io/badge/ID-3ks-brightgreen?style=for-the-badge https://img.shields.io/static/v1?label=NAME&amp;message=Guan&amp;color=brightgreen?style=for-the-badge https://img.shields.io/static/v1?label=&amp;message=&amp;color= 动态徽章预置自定义参考链接shields.io GitHub 项目徽章的添加和设置 如何让你的 GitHub 项目表面上更专业 为你的Github生成漂亮的徽章和进度条 Adding a workflow status badge to your repository","link":"/2020/07/17/github-badges/"},{"title":"博客切换至 Hexo","text":"最近将博客的生成器更改为了 Hexo，并使用了主题 icarus，当然，依然是静态博客。 整个迁移过程异常的顺利、简单，并且博客也比之前漂亮了很多，在这里做个笔记，算是自己的一个 icarus 入门教程吧。 背景之前使用的是 Hugo 框架生成静态博客，虽然 Hugo 宣称是世界上最快的网站生成器，且很多大佬都表示 Hugo 很简单，但我个人觉得并非如此。原因有如下几点： 性能：静态博客最终生成的都是 html、css、js，然后随便挂个 web 服务器就可以发布，撑死我每天也写不出两篇文章，此时渲染几十毫秒，和渲染几秒对我都没多大影响。 学习成本：静态博客推崇的是约定优于配置，什么意思呢？静态博客简单的代价就是很多东西都是有默认配置的，如果你想要自定义一些东西，你必须得查看文档，看看都有些什么约定、参数，都是用来干嘛的、怎么调整。在这方面，Hexo 的文档只有 24 页，而 Hugo 的文档有 100 多页，Hugo 确实更强大，但如果你想要做一些修改，也需要更高的学习成本。 这里主要是文档，Hugo 不仅有 100 多页的文档，而且还都是英文的。而 Hexo 不仅文档只有十几页，而且还有中文翻译（虽然有点滞后，但不影响了解 Hexo）。 生态：Hugo 与 Hexo 都有三百多个主题，看起来差不多，但很多主题的质量其实很差的，我不是针对谁，我是说在在座的两位。Hugo 我至今没有找到一个简单且满意的主题，而 Hexo，从找主题，到安装，简单修改，运行，一共几个小时就搞定了，丝滑般的享受，我的头发又回来了o(￣▽￣)ブ 总结一下：Hugo 很强，也很难。有多难？我觉得比 Kubernetes 还难！Hexo 各方面都很简单，优秀的主题同样可以赋予静态博客生命，如何选择取决于自己。 以下，是自己使用 Hexo 以及 icarus 主题的一点笔记。 安装 node.js前往 nodejs.org 根据自己的平台下载对应的版本。 对于 Ubuntu 用户，你也可以执行以下命令： 1$ apt-get install -y npm 安装完成后查看 node 和 npm 版本信息，确保安装成功： 1234$ node --versionv12.16.1$ npm --version6.14.6 安装 Hexo在安装好 node.js 后，执行下面的命令即可： 1$ npm install hexo-cli -g 安装完成后查看 hexo 版本信息，确保安装成功： 1234567891011121314151617$ hexo -vhexo: 4.2.1hexo-cli: 3.1.0os: Linux 4.4.0-18362-Microsoft linux x64http_parser: 2.7.1node: 8.10.0v8: 6.2.414.50uv: 1.18.0zlib: 1.2.11ares: 1.14.0modules: 57nghttp2: 1.30.0openssl: 1.0.2nicu: 60.2unicode: 10.0cldr: 32.0.1tz: 2017c 初始化博客并下载 Icarus 主题 先切换至你写代码的目录，然后初始化博客 12$ hexo init &lt;your-blog-name&gt;$ cd &lt;your-blog-name&gt;/themes 注意：your-blog-name 是一个目录名，你应该将他替换为自己需要的名字。 下载 Icarus 主题 1git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus -b &lt;version number&gt; --depth 1 注意： 是 icarus 主题的版本号，你可以在 icarus release 查看可用的版本号。 使用 Icarus 主题 编辑 _config.yml 文件，指定主题： 1$ cd ../ &amp;&amp; vi _config.yml 找到 theme 项，将值设为 icarus： _config.yml1theme: icarus 启动博客1$ hexo server 此时，可能会提示你缺少一些依赖，需要安装，比如这种： 根据给出的提示，运行安装命令就可以了。 随后你就可以访问 http://localhost:4000 查看你的博客了。 虽然此时的博客还是一个毛坯，但看起来还是挺好看的，不得不说 icarus 的作者这方面做的很好，接下来就是根据自己的需求，做一些调整了。 样式改动对原主题样式的修改都集中在 themes/icarus/include/style/custom.styl 文件内。 about 页和 404 页about 页面，需要创建一个 source/about/index.md 的文件来进行描述，生成的站点即可正常访问 about 页面 404 页面，需要创建一个 source/404.md 的文件来描述，会生成一个 404.html，需配合 web 服务器使用。 CDN 加速所有的静态资源，如：css、js、图片、字体文件均通过 CDN 加速，站点仅提供 html 内容。 文章的图片在写作时就直接通过图床传到 CDN 上了。 而网页的静态文件，使用的方法很土，手动修改了 themes/icarus/layout 下所有涉及引入静态资源代码的路径为 CDN 路径，可以通过关键字 自定义 CDN 找到它们。 GitHub Action使用 GitHub Action，自动部署到了 GitHub Page 和自己的服务下，相关内容可以查看 .github/workflows/ci.yml 文件 参考链接hexo.io Icarus快速上手 Icarus用户指南","link":"/2020/07/17/go-to-hexo/"},{"title":"重读 The Way to Go","text":"The Way to Go 是一本经典的 Go 语言入门教学书籍，中文译本主要由 unknown 翻译，我已经阅读过多次了，每次都会有有一些收获，入坑 Go 正好两周年，正好最近在找工作，遂再次学习了本书（指译本，下同）的内容，并将本次的收获简单做一下记录。 阅读链接项目地址：unknwon/the-way-to-go_ZH_CN 目录：directory 国内很多 Gopher 入门的第一本书就是 The Way to Go，据我所知，很多网站都能找到本书的内容。 如果你也对这本书感兴趣的话，我只推荐你通过上面的链接进行阅读。The Way to Go 这本书已经做出过多次修订，译文同样需要更新，在这方面，阅读译本原文可以获得最好的体验。 main.go查看源文件1234567package mainimport \"fmt\"func main() { fmt.Println(\"hello world\")}","link":"/2020/07/17/the-way-to-go/"},{"title":"GORM V2 带来的知识盲区","text":"GORM v2 是完全重写的，现已正式发布，带来了大量的改进以及新功能，我在翻译文档的过程中，遇到了一些以前没见过的新知识，在这里仅对相关概念做一下记录。 如果想要查看完整的内容，应该访问 release note 或者 发布说明 HintsOptimizer Hints、Index Hints、Comment Hints，jinzhu 大佬的建议是不翻译，中文词不达意 这是提示相关的功能，用于优化 SQL 等，需要了解 sql 执行过程帮助理解。 在 GORM 中的使用可以参考：https://gorm.io/docs/hints.html Prepared Statement ModePrepared Statement Mode 应该是一个来自 JAVA 的概念，可以译作预编译模式，作用是将生成的 SQL 缓存下来，提高后续的效率。 在 GORM 中的使用可以参考：https://gorm.io/docs/performance.html#Caches-Prepared-Statement Preload 和 Joins Preloadv1 仅支持 Preload。 在进行预加载时，Preload 和 Joins Preload 作用类似，区别在于 Preload 会通过两条 SQL 完成查询，而 Joins Preload 通过一条 SQL 完成查询，至于用哪个就看自己的情况和习惯了。 此外，Joins Preload 还可以指定链接方式和字段等，更加灵活。 在 GORM 中的使用可以参考：https://gorm.io/docs/performance.html#Caches-Prepared-Statement 嵌套事务相关概念有：Nested Transaction/SavePoint/RollbackTo SavePoint，即：嵌套事务、保存点、回滚至保存点 之前只知道事务和回滚，没想到还可以套娃，触及到知识盲区了 在 GORM 中的使用可以参考：https://gorm.io/docs/transactions.html Group Conditions分组条件，不算新内容，只是一个以前没注意到的示例，条件较多时可以参考 在 GORM 中的使用可以参考：https://gorm.io/docs/advanced_query.html#Group-Conditions Batch Insert批量插入，一个实用的功能 在 GORM 中的使用可以参考：https://gorm.io/docs/create.html#Batch-Insert Upsertupdate or insert 在数据冲突时（例如要 insert 的数据的存在主键或唯一索引冲突），如何处理，也是一个比较常见的问题。 在 GORM 中的使用可以参考：https://gorm.io/docs/create.html#Upsert-On-Conflict DryRun干运行模式，作用是：仅生成但不执行 SQL 语句，这在调试的时候很有用 在 GORM 中的使用可以参考：https://gorm.io/docs/gorm_config.html#DryRun 字段级权限控制比较高级的用法，字段级别的权限控制，通过 tag 定义 在 GORM 中的使用可以参考：https://gorm.io/docs/models.html#Field-Level-Permission 全新的插件系统一个非常亮眼的功能，为 GORM 生态打下了基础。 目前已有的插件包括：多数据库支持，读写分离支持，prometheus 集成 如何编写插件可以参考：https://gorm.io/docs/write_plugins.html 其它此外，还有大量更新，查看 GORM Docs 和 GORM 2.0 Release Note 获取详情 参考链接GORM Docs","link":"/2020/07/28/gorm-faq/"},{"title":"复习 Mysql","text":"这不是一个完整的教程，知识我重新学习 Mysql 的知识，并做了一些零碎笔记。 别名对于字段别名可以这样： 1select name as 姓名,age from tb_user; 也可以： 1select name 姓名,age from tb_user; 多个字段用 , 分隔，字段别名可以不加 as，直接用空格分隔即可。 表别名类似，可以这样： 1select A.name from tb_user as A; 也可以： 1select A.name from tb_user A; DISTINCTdistinct 是对结果去重的，它是作用在所有选择字段上的，而不是单个字段。 例如： 1select distinct name,age from tb_user; 其效果类似于： 1select distinct (name,age) from tb_user; 如果我们想要对查询多个字段，且根据某一个字段去重，应该使用 GROUP BY： 1select name,max(age) from tb_user group by name; BETWEEN AND 边界下面的语句类似于，age &gt;= 20 &amp;&amp; age &lt;= 30 1select * from tb_user where age BETWEEN 20 AND 30; 下面的语句类似于，age &lt; 20 || age &gt; 30 1select * from tb_user where age NOT BETWEEN 20 AND 30; ESCAPE在使用 like 子句的通配符时，如果字段恰好包含了通配符怎么办呢？ 例如：在下面这个查询中，我们确实想查询包含 前5% 关键字的内容，默认情况下 % 会被视为通配符。 1select * from where tb_user where description like &quot;%前5%%&quot;; 此时我们可以使用 ESCAPE，escape 意为避开、避免，在 like 子句中，escape 字符后面的通配符会被视为普通字符： 12select * from where tb_user where description like &quot;%前5!%%&quot; escape '!'; select * from where tb_user where description like &quot;%前5#%%&quot; escape '#'; 参考链接name","link":"/2020/07/29/review-mysql/"},{"title":"Network Manager 入门","text":"Network Manager 入门笔记，完成基本的网络配置 介绍NetworkManager(NM) 是 2004 年 Red Hat 启动的项目，旨在能够让 Linux 用户更轻松地处理现代网络需求，尤其是无线网络，能自动发现网卡并配置 IP 地址。 在 rhel8/centos8 上，network.service 已被废弃，我们只能通过 NetworkManager 进行网络管理。 当然，我们不需要直接使用 NetworkManger 管理网络，我们可以通过下面这些工具进行 NetworkManger 管理，他们类似于 NetworkManger 客户端： nmcli：命令行。这是最常用的工具，本文将详细讲解该工具使用。 nmtui：在shell终端开启文本图形界面。示意图见本文最后的Tips Freedesktop applet：如GNOME上自带的网络管理工具 cockpit：redhat 自带的基于 web 图形界面的管理工具，具有 dashborad 和基础管理功能。 本文只介绍 NetworkManager 相关知识以及 nmcli 的使用方法。 概念在 NM 中，有两个主要对象：设备（device）和 连接（connection），它们是一对多的关系，即一个设备可以对应多个连接。但是，一个设备只能有一个活跃的连接，其它连接会变为非活跃、不可用。 设备（device）我们可以通过命令 nmcli d 或 nmcli device 者查看当前设备状态： 1234$ nmcli dDEVICE TYPE STATE CONNECTIONens33 ethernet connected ens33lo loopback unmanaged -- 输出包含四列，分别表示：设备名、设备类型、状态、激活地连接名。 设备名和连接名可以相同，但他们是不同的对象，在后续的操作中注意不要被同名的情况误导。 并非所有的设备都会被 NM 接管，设备常见的状态有： 状态 描述 connected 已被 NM 接管，设备当前有活跃的连接 disconnected 已被 NM 接管，设备当前没有活跃的连接 unmanaged 未被 NM 接管，但可以通过命令接管该设备 unavailable 未被 NM 接管，不可用，NM 无法接管该设备，通常由网卡被 down 掉导致，例如：ip link set ethX down NM 只能管理 已被 NM 接管 设备的网络配置。 连接（connection）我们可以通过命令 nmcli c 或 nmcli connection 者查看当前连接状态： 123$ nmcli cNAME UUID TYPE DEVICEens33 d20368c4-4112-4773-b3a5-c8d06907c349 ethernet ens33 输出包含四列，分别表示：连接名名、唯一标识 UUID、连接类型、对应的设备名。 连接的常见状态有： 状态 描述 connected 活跃的连接 disconnected 非活跃的连接 连接的状态由输出结果的颜色来判断，绿色为活跃，正常颜色为非活跃： 你也可以执行 nmcli device 根据设备的状态及其对应的连接来判断连接的状态。 基本网络配置想要正常访问互联网，需要配置：IP 配置方法（DHCP 或手动）、IP 地址、子网掩码、网关、DNS。而服务器一般使用静态 IP： 1234# 配置nmcli c mod ens33 ipv4.method 'manual' ipv4.addr '192.168.7.10/24' ipv4.gateway '192.168.7.2' ipv4.dns '8.8.8.8'# 使更改生效nmcli c up ens33 其中： 在 nmcli 中，很多关键字都支持缩写，c 是 connection 的缩写，mod 是 modify 的缩写，d 是 device 的缩写。 并不是每一个连接都要配置 DNS，因为默认情况下，有一个系统默认的全局 DNS（/etc/resolve.conf）。只有当你需要为这个连接指定特别的 DNS 时才需要配置。 ipv4.addr 等属性列表，可以通过命令 nmcli c show ens33 查看，然后根据自己的需要进行修改。 创建连接1234# 创建连接nmcli c add type ethernet ifname ens33 con-name eth0 ipv4.method 'manual' ipv4.addr '192.168.7.11/24' ipv4.gateway '192.168.7.2'# 激活（切换）连接nmcli c up eth0 其中： type ethernet 指定连接类型 ifname ens33 指定对应的设备名 con-name eth0 指定连接名，可以忽略，此时会自动生成连接名 ipv4.method 等后续配置，可以在创建时就指定，也可以创建好链接后，再修改 eth0 激活后，之前的 ens33 连接会变为非活跃状态 设备是否（例如开机）自动连接可以通过 nmcli d set &lt;ifname&gt; [autoconnect yes|no] [managed yes|no] 来配置 多个 IP虽然一个设备只能有一个激活的连接，但这不代表只能有一个 IP，我们可以通过以下方式添加多个 IP 单连接多 IP12nmcli c mod eth0 +ipv4.addr '192.168.7.12/24'nmcli c up eth0 注意，ipv4.addr 前面有一个 + 表示追加，对应的，还可以使用 - 表示移除，而无符号则表示覆盖 桥接123456# 添加桥接连接nmcli c add type bridge ifname eth1 con-name eth1# 配置 IPnmcli c mod eth1 ipv4.method 'manual' ipv4.addr '172.16.1.10/16' ipv4.gateway '172.16.0.2'# 激活nmcli c up eth1 其中： type bridge 表示添加一个桥接连接，同时它会自动创建一个桥接设备，形成逻辑上的两个设备，这样我们就可以同时有两个活跃的连接 其它-hnmcli 拥有很完整的帮助文档，在使用时你可以经常加上 -h 查看。简单来讲，主要就是 connection 和 device 对象的增删改查。 命令补全nmcli 不仅支持命令缩写，还支持 tab 命令补全，前提是安装 bash-completion，可以通过如下命令安装它： 1dnf install -y bash-completion 完成后，重新登录一下即可。 参考链接基于RHEL8/CentOS8的网络IP配置详解 使用 NETWORKMANAGER 命令行工具 NMCLI （由 RedHat 提供的文档，并且提供了中文版）","link":"/2020/08/25/network-manager/"},{"title":"alias 使用","text":"一个简单实用的命令，通过 alias 命令设置一个别名，比如 alias c='clear' 可以让输入 c 与 clear 的效果是相同的。 alias 的用法非常简单： 1$ alias 别名='原命令 -选项/参数' alias 命令有两种使用方式，在命令行中直接使用、将命令写入至 bashrc 文件，而写入 bashrc 文件又分为写入用户文件和系统文件。 命令中行使用1$ alias cdgo='cd /go/src/github.com/3ks/3ks.dev' alias 会立即生效，但只会在本次会话生效，对于其它会话（包括其他用户、该用户的其它会话）都无效。 写入用户 bashrc 文件将 alias 写入用户 bashrc 文件可以带来永久的效果，这些 alias 对该用户有效，该文件位于 ~/.bashrc： ~/.bashrc1$ alias cdgo='cd /go/src/github.com' 保存退出后，执行下面的命令使之生效： 1source ~/.bashrc 写入系统 bashrc 文件将 alias 写入系统 bashrc 文件可以带来永久的效果，这些 alias 对系统中的所有用户有效，该文件位于 /etc/bashrc： /etc/bashrc1$ alias cdgo='cd /go' 保存退出后，执行下面的命令使之生效： 1source ~/.bashrc alias 优先级对于存在冲突的 alias，命令行优先于用户 bashrc 文件优先于系统 bashrc 文件 参考链接alias命令","link":"/2020/08/26/alias/"},{"title":"各种简写及其含义","text":"一些简写的全写及其含义。 目的在 GitHub 的开源项目中与他们协作时，会用到大量的缩写字母。 这并不是什么高大上的东西，甚至说有点土。不信？来看几个例子 gkd、dbq、xjj、xgg ，什么意思呢？其实这种汉语拼音的首字母缩写，意思是 搞快点、对不起、小姐姐、小哥哥。是不是瞬间觉得很土了！听说现在的 00 后们很喜欢这种 缩写体 聊天方式。 什么，你接受不了？不管你是 70 后、80 后还是 90 后。gg、mm、886、520 总用过吧！当年 40 后、50 后、60 后也受不了你们！ 这些简写字母其实是各种短语的 首字母 或 首字母谐音 缩写，目的是为了方便多人协作和交流。 其实我认为这些缩写本质上来说，是一种简单高效的交流方式，只是需要花点时间去学习，了解其含义。 本文会介绍英文中的一些单词首字母缩写及其含义，主要分为三类，英文单词缩写、汉语拼音缩写和开源协作类缩写。 其中开源协作类的内容会稍微复杂一点，主要面向 开发者 人群做介绍，因为其可能不仅仅是表达某种意思，还会被 机器人 视为 指令 并做一些自动化处理，所以还会介绍其作用，以及在什么哪一个仓库有效。既然说到了自动化处理，还会介绍一些其它的非缩写的 指令。好吧，其实我主要是想说的 Kubernetes 相关的仓库。 英文单词缩写体老美们懒惰腐败的交流方式： 缩写 原文 含义 R U OK? are you ok? 你还好吗？ NG no good 不够好（一般指导演认为不够好，需要重拍） GG good game 一局精彩的游戏 NGG no good game 这不是一局精彩的游戏 bashrc bash run command bashrc 一般是某个文件，在一个新建 bash 开始时，会执行 bashrc 中的命令，可以将其看成一个初始化脚本 汉语拼音缩写体深受小鲜肉们喜爱的聊天交流方式。 缩写 原文 出处 awsl 阿伟死了 - xswl 笑死我了 - gkd 搞快点 - 开源协作类这一部分的前 3 列 非开发者 人群也可以阅读，本质上还是一些英文缩写，可以了解一下 程序员 们是如何进行全球协作开发的。 一般的指令都会 @someone 某个人，这跟你在微博上 @某个人 是一样的意思。 后面几列专业性稍强，主要面向 程序员 做介绍。 这一部分的内容会有缩写、缩写指令、非缩写指令三种类型，主要介绍在 Kubernetes 系的开源仓库中协作时会用到的一些缩写。 缩写 原文 含义 k8s bot 动作 /cc @someone see see 看看（请帮我 review 一下代码） 自动将你 @ 的人添加至 reviewer 列表，表示你希望此人帮你 review 代码。 /cc @someone see see 看看（请帮我 review 一下代码） 自动将你 @ 的人添加至 reviewer 列表，表示你希望此人帮你 review 代码。 LTLR Too Long To Read 内容很长警告！ - GA General Availability 一般指某软件的首个可用版本 - 参考链接聊天字母缩写曝光：你对00后的世界一无所知","link":"/2020/08/26/argot/"},{"title":"个人常用的 docker-compose 配置文件","text":"在平时做各种小实验时，通过 docker-compose 可以快速的搭建一个环境，记录一下自己用到的一些清单 习惯 根目录是 /cs （containers） 为每个项目创建一个目录，存放其相关的资源文件、docker-compose.yaml 等 Mysqldocker-compose.yaml123456789101112version : '2'services : mysql : image : mysql:latest container_name : mysql8 ports : - \"3306:3306\" volumes : - \"/cs/mysql/data:/var/lib/mysql\" environment : MYSQL_ROOT_PASSWORD : password123 restart : always Redisdocker-compose.yaml1234567891011version : \"2\"services : redis : image : redis:latest container_name : redis volumes : - /cs/redis/data:/data ports : - \"6379:6379\" restart : \"always\" entrypoint : redis-server --requirepass \"password123\" FTPdocker-compose.yaml1234567891011121314151617version: '2'services: ftpd_server: image: stilliard/pure-ftpd:hardened container_name: pure-ftpd ports: - \"21:21\" - \"30000-30009:30000-30009\" volumes: - \"/images/ftp/data:/home/guan/\" - \"/images/ftp/passwd:/etc/pure-ftpd/passwd\" environment: PUBLICHOST: \"192.168.1.90\" FTP_USER_NAME: guan FTP_USER_PASS: mypass FTP_USER_HOME: /home/guan restart: always 如果连接卡在读取目录列表可以参考 FileZilla 读取目录列表失败的解决办法 ftp Nginxdocker-compose.yaml123456789101112version: '2'services: nginx-server: image: nginx:latest container_name: nginx-server ports: - \"80:80\" volumes: - \"/cs/nginx/html:/usr/share/nginx/html\" - \"/cs/nginx/nginx.conf:/etc/nginx/nginx.conf\" - \"/cs/nginx/log:/var/log/nginx\" restart: always 你还需要准备静态文件，并将其放到 /cs/nginx/html/ 下 你还需要准备 nginx 的配置文件，其绝对路径为 /cs/ngix/nginx.conf 这是一个 nginx.conf 的示例： nginx.conf1234567891011121314151617181920212223242526272829user nginx;worker_processes 1;error_log /var/log/nginx/error.log warn;pid /var/run/nginx.pid;events { worker_connections 1024;}http { include /etc/nginx/mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] &quot;$request&quot; ' '$status $body_bytes_sent &quot;$http_referer&quot; ' '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;'; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; include /etc/nginx/conf.d/*.conf;} Postgresqldocker-compose.yaml1234567891011version : \"2\"services : postgres : image : \"postgres:latest\" container_name : \"postgres\" ports : - \"5432:5432\" volumes : - \"/cs/postgres/data:/var/lib/postgresql/data\" environment : POSTGRES_PASSWORD : \"mypassword\" GitLab版本区别GitLab 有两个版本，CE 和 EE。而 EE 又提供了多种级别的付费计划（包括一种免费的计划）。 免费的 GitLab EE 与 CE 完全相同，区别在于升级到付费计划时，GitLab EE 更方便。如果有付费的可能，则最好安装 GitLab EE。如果完全没有付费的打算，则安装 GitLab CE。 可以查看 Community Edition or Enterprise Edition 获取详情 配置文件docker-compose.yaml12345678910111213web: image: 'gitlab/gitlab-ce:latest' restart: always hostname: 'web' environment: GITLAB_OMNIBUS_CONFIG: | external_url 'http://192.168.7.11:80' ports: - '8080:80' volumes: - '/cs/gitlab/config:/etc/gitlab' - '/cs/gitlab/logs:/var/log/gitlab' - '/cs/gitlab/data:/var/opt/gitlab' 其中： external_url 是必填的，其端口决定了其监听端口，我们在 ports 映射端口时需要注意。其地址会影响 clone 等按钮生成的 URL，在映射端口不一致的情况下，需要注意一下。 GITLAB_OMNIBUS_CONFIG 还支持其它参数，查看 Pre-configure Docker container 获取详情 GitLab 启动速度较慢，可以耐心等待几分钟，默认用户名为 root，密码会在首次访问时要求设置。 Harbor下载离线安装包12$ wget https://github.com/goharbor/harbor/releases/download/v2.0.2/harbor-offline-installer-v2.0.2.tgz$ tar xvf harbor-offline-installer-v2.0.2.tgz 修改配置文件123456789101112131415cd harborcp harbor.yml.tmpl harbor.yml``` 编辑 `harbor.yml` 文件，其参数及含义可以参考 [Configure the Harbor YML File](https://goharbor.io/docs/2.0.0/install-config/configure-yml-file/)对于测试，个人习惯修改的配置有：```yamlhostname: 192.168.7.11data_volume: /cs/harbor/harbor/data # 数据目录log: local: location: /cs/harbor/harbor/log # 日志目录# https # 想使用 HTTP 的话，需要把 HTTPS 相关的配置项注释掉 安装对于测试环境，可以直接执行以下命令开始安装： 1$ sudo ./install.sh 对于有要求的环境（如安全、高可用等），参考官方文档 Harbor 的默认用户是 admin，默认密码是 Harbor12345，首次登录后，应尽快更改密码。 参考连接mac或者linux通过docker管理nginx部署静态文件 nginx 403 forbidden 二种原因 postgres postgresql数据库改变data目录 Docker上部署FTP服务器（基于stilliard/pure-ftpd） Install GitLab using Docker Compose Harbor Installation and Configuration","link":"/2020/08/26/common-docker-compose/"},{"title":"fork 炸弹","text":"偶然看到一串奇怪的命令，手贱执行了一下，没想到系统直接卡死 代码1alias clear=':(){ :|: &amp;};:' 一次偶然的机会，我看到了上面这段代码，然后手贱执行了一下： 1:(){ :|: &amp;};: 电脑直接就卡死了，过了几分钟，我才回过神来，是这段代码导致的。 网上搜了一下，这段代码就是著名的 fork bomb 即 fork 炸弹，其会以指数级的速度快速创建线程，迅速将整个系统的资源耗尽，最终导致系统卡死。 fork 炸弹一旦引爆，基本只能重启。 代码解析最开是看到这段代码一脸懵逼，怎么就卡死了呢，网上搜了一下，大致了解了其工作流程。 在这一行代码中，我们定义了一个名为 : 的函数： 1:(){ :|: &amp;};: 把 : 换成一个常见的函数名，比如 bomb，那么上面这段代码可以翻译为： 1bomb(){ bomb|bomb &amp;};bomb 再展开一下： 1234bomb(){ bomb|bomb &amp;};bomb 这样看起来就直观多了，前三行定义了一个函数，第四行调用了该函数。 而函数的行为是：后台的、通过管道递归调用自身两次 由于管道操作会创建新的进程，所以每次调用函数都会产生两份拷贝，这样函数就会呈指数级的增长，可以在极短的时间内耗光计算机资源。 参考链接fork 炸弹","link":"/2020/08/26/fork-bomb/"},{"title":"在 Centos 8 上安装 Docker","text":"一个安装 Docker 的笔记 手动安装 containerd.io1Problem: package docker-ce-3:19.03.4-3.el7.x86_64 requires containerd.io &gt;= 1.2.2-3 如果你收到类似上面这种提示，则需要手动安装 containerd.io 目前 docker 版本已经来到 19+，其对组件 containerd.io 的要求是 &gt;= 1.2.2-3，由于 Centos 软件源更新不及时（后续版本更新后这个问题可能就不存在了），默认源下没有符合要求的版本，所以该组件无法完成安装，这里我们需要手动安装 containerd.io 安装通过阿里云镜像安装： 1dnf install https://mirrors.aliyun.com/docker-ce/linux/centos/7/x86_64/stable/Packages/containerd.io-1.2.6-3.3.el7.x86_64.rpm 如果你的服务器在国外，或者网络足够好的化，也可以直接从 docker 官方下载安装： 1dnf install https://download.docker.com/linux/centos/7/x86_64/stable/Packages/containerd.io-1.2.6-3.3.el7.x86_64.rpm 此外，上面的命令中的 rpm 包可能随着时间的推移而变得陈久，但你可以直接访问 Docker 官方 或者 阿里云镜像 查看并选择最新的 rpm 包。 安装 Docker添加仓库添加 Docker 官方的仓库信息： 12$ sudo yum install -y yum-utils$ sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo 安装正常的 Docker 安装： 1$ sudo yum install docker-ce docker-ce-cli 启动并添加开机启动项1$ sudo systemctl enable --now docker 验证1$ sudo docker run hello-world 等待镜像启动完成后，如果你可以看到的内容类似于下面这样，则表示安装成功： 12345678910111213141516171819202122$ sudo docker run hello-worldHello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal.To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bashShare images, automate workflows, and more with a free Docker ID: https://hub.docker.com/For more examples and ideas, visit: https://docs.docker.com/get-started/ 镜像加速由于网络方面的原因，我们在拉取镜像的时候速度可能会很慢，对此，我们可以通过编辑配置文件，配置镜像来加快其速度。 访问 阿里云-容器镜像服务 获取自己专属的镜像加速地址。该页面附带了如何配置镜像的说明。 在 Linux 系统中，默认情况下，Docker 的配置文件是 /etc/docker/daemon.json（Configure the Docker daemon） 配置好镜像后，你需要执行以下命令： 12$ systemctl daemon-reload $ systemctl restart docker 安装 Docker Compose12$ sudo curl -L \"https://github.com/docker/compose/releases/download/1.26.2/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose$ sudo chmod +x /usr/local/bin/docker-compose 随后，你可以运行下面的命令查看 Docker Compose 版本，并以此判断是否安装成功： 12$ docker-compose -vdocker-compose version 1.26.2, build eefe0d31 Docker Compose 可用于单机简单的编排，在学习、测试时是一个不错的选择。对于更加复杂的容器编排，唯一的选择是 Kubernetes 卸载卸载 Docker Compose1sudo rm /usr/local/bin/docker-compose 卸载 Docker1$ sudo yum remove docker-ce docker-ce-cli containerd.io 但是，相关的镜像、容器、卷以及其它自定义目录下的内容不会被自动删除，你需要自己手动删除它们： 123$ sudo rm -rf /var/lib/docker# 删除其它自定义目录$ sudo rm -rf ... 参考链接Install Docker Engine on CentOS CentOS之——CentOS8 安装 Docker Install Docker Compose","link":"/2020/08/26/install-docker-on-centos-8/"},{"title":"docker 的一些操作","text":"在使用 docker 时的一点及其，本质上来讲学好 linux 的命令，用任何软件都很简单。 筛选镜像docker imagedocker image 的输出类似于这样，如果要批量操作镜像，我们一般会选择镜像名：tag 或者 IMAGE ID 的方式进行批量操作 1234$ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEalpine 3.10.4 af341ccd2df8 2 months ago 5.56MBredis 5.0.5-alpine ed7d2ff5a623 7 months ago 29.3MB 筛选镜像keyword 表示镜像关键字，可以是镜像名、Tag、ID、体积等，总之是某个关键字，如果为 . 则匹配所有镜像： 1$ docker images | grep \"keyword\" 列出镜像按镜像名列出1$ docker images | grep \"keyword\" | sed '1d' | awk '{print $1}' 按镜像名：tag列出1$ docker images | grep \"keyword\" | sed '1d' | awk '{print $1\":\"$2}' 按 IMAGE ID 列出1docker images | grep \"keyword\" | awk '{print $3}' 批量操作批量导出镜像按照 镜像名：Tag 的风格导出，以便在其它地方导入后可以方便的识别镜像名称 执行下面这条命令即可将所有包含关键字的镜像导出为单个文件 all.tar.gz 1IMAGES_LIST=($(docker images | grep \"keyword\" | sed '1d' | awk '{print $1\":\"$2}')) &amp;&amp; docker save ${IMAGES_LIST[*]} -o all.tar.gz 批量导入镜像获取到一个镜像包后，（例如上面导出的 all.tar.gz ），执行 docker load &lt; 包名 即可将包内的所有镜像导入至本机： 1docker load &lt; all.tar.gz 批量删除镜像1docker rmi $(docker images | grep \"keyword\" | awk '{print $3}') 或者 1docker rmi -f $(docker images | grep \"keyword\" | awk '{print $3}') 如果遇到多个镜像拥有相同的 IMAGE ID，在第二种方式中，会强制删除所有所有与 IMAGE ID 匹配的镜像，而不论其他镜像是否与 keyword 匹配。 第一种方式则不会删除这种镜像 参考链接逐个和批量导出导入docker镜像 docker 如何批量删除镜像","link":"/2020/08/27/docker-opreation/"},{"title":"一些混乱的草稿","text":"记录了各种各样的内容，暂时没有想好为其单独开一篇博客，先放在这儿吧 为什么 cp -f 依然提示是否覆盖linux cp拷贝覆盖不提示 如何给网页指定 favicon设置favicon的几种方式 如何给谷歌云新建的 VM 实例设置 root 密码谷歌云开启SSH及设置root密码 如何修改 Centos 的 hostname1$ hostnamectl set-hostname &lt;your-hostname&gt; 修改后立即生效，但需要重新登录 shell，才能看到效果 参考：centos修改主机名的正确方法 意外断电导致 CentOS 异常解决方式与 VMWare的CentOS虚拟机断电或强制关机出现问题 一致 修改时区CentOS7 开始引入了一个 timedatectl 工具，直接运行命令： 1$ timedatectl set-timezone Asia/Shanghai 也可以手动修改时区文件： 1$ cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime 如果设置时区后，时间依然快了 8 小时,可以执行下面的命令： 1$ ln -s -f /usr/share/zoneinfo/Universal /etc/localtime 参考： CentOS 7 修改系统默认时区 CentOS 7系统时间与实际时间差8个小时 ifconfig command not found1$ dnf install -y net-tools 关闭 SELinux临时关闭： 1$ setenforce 0 永久关闭： 编辑 /etc/selinux/config 文件，将 SELINUX 项的值修改为 disabled /etc/selinux/config123456# This file controls the state of SELinux on the system.# SELINUX= can take one of these three values:# enforcing - SELinux security policy is enforced.# permissive - SELinux prints warnings instead of enforcing.# disabled - No SELinux policy is loaded.SELINUX=disabled 参考：查看 SELinux状态及关闭SELinux 黑苹果安装提要 硬件选择，选对硬件就成功了一半。 镜像下载，去远景论坛看看最新的镜像，也可以去自己的云盘找找库存 制作启动盘，关键软件 transMac。制作完成后，根据硬件选择合适的 config.list 文件 安装系统，排错，谷歌，爬论坛 安装软件，调整 putty 的一些使用问题由不正确的配置导致在 putty 中回退、方向键等乱码问题，按下图箭头所指设置即可： 小键盘等乱码问题，按下图设置箭头所指设置即可： 设置完记得保存 session sudo 出现 command not foundsudo 读取的 PATH 路径与常规用户不同，而目标程序恰好没有被包含，就会出现 command not found 的情况。 编辑 /etc/sudoers 文件，将目标程序所在的路径追加上即可。 例如： /etc/selinux/config1Defaults secure_path = /sbin:/bin:/usr/sbin:/usr/bin 可以修改为： /etc/selinux/config1Defaults secure_path = /sbin:/bin:/usr/sbin:/usr/bin:/usr/local/bin:/go/bin 参考：sudo 执行提示 Command not found emoji 字符大全emoji cheat sheet emoji 备忘录，支持的常见网站有：GitHub、Youtube、Discord、Gitter 以及 Mattermost 等。 不同网站对字符渲染效果可能有所不同，但所表达的意思都是一样的 dig 命令dig，Domain Information Groper，域信息搜索器，CentOS8 下的安装命令是： 1sudo dnf install -y bind-utils linux dig 命令 dig 命令详解","link":"/2020/08/27/draft/"},{"title":"使用 firewall-cmd 命令管理防火墙","text":"Linux 的新防火墙软件，跟 iptables 差不多的工具。firewall-cmd 是 firewalld 的 cli 管理工具，firewalld 是centos7 的一大特性，最大的好处有两个：支持动态更新，不用重启服务；第二个就是加入了防火墙的 zone 概念。 管理命令查询 zone 与 接口信息123$ firewall-cmd --get-active-zonespublic interfaces: ens33 该命令会列出各接口所属的 zone，默认情况下，接口都在 public 下，public 也是模式 zone 重新加载防火墙规则1$ firewall-cmd --reload 在修改防火墙规则后，通过该命令使规则生效 规则管理查看开放端口情况1$ firewall-cmd --zone=public --list-ports 查看指定 zone 下开放的端口列表，如果未指定 zone 则查看默认 zone。 主要注意的是： 永久改动的规则，在 reload 之前不会生效，此时也不会被列出； 临时改动的规则，会立即生效，在 reload 之后失效； 开放端口端口的语法是： 1&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt; 即指定一个 IP 或 IP 范围，以及协议。常见的协议是 TCP、UDP 例如： 1238080/tcp8081/udp8082-8085/tcp 示例： 123456$ firewall-cmd --add-port=8080/tcpsuccess # 添加成功反馈$ firewall-cmd --add-port=8081/udp --zone=publicsuccess # 添加成功反馈$ firewall-cmd --add-port=8082-8085/tcp --zone=public --permanentsuccess # 添加成功反馈 没有指定 zone 的规则，自动使用默认 zone 带有参数 --permanent 的规则是永久生效的，不会在重启后失效 规则修改完成后，不要忘记重新加载规则，使其生效 禁用端口默认情况下下，未开启端口即视为禁用，对于已经开放的端口，我们可以移除相关规则，使其被禁用。 禁用端口的关键字是 --remove-port，其用法与 ---add-port 类似。 示例： 1234567891011121314$ firewall-cmd --remove-port=8080/tcpsuccess # 禁用成功反馈$ firewall-cmd --remove-port=8081/udp --zone=publicsuccess # 禁用成功反馈$ firewall-cmd --remove-port=8082-8100/tcp --zone=public --permanentWarning: NOT_ENABLED: 8082-8100:tcpsuccess$ firewall-cmd --remove-port=8083/tcp --zone=public --permanentWarning: NOT_ENABLED: 8083:tcpsuccess$ firewall-cmd --reload # 重新加载规则success$ firewall-cmd --list-port # 禁用没有生效8082-8085/tcp 需要注意的是，开放与禁用一条规则，涉及的端口写法需要完全一致。 我们前面开放的是 8082-8085/tcp 端口，这里禁用的是 8082-8100/tcp 以及 8083/tcp，此时会有成功反馈，但也有一个警告提示我们：这些端口本就没有开放。重新加载规则列表，8082-8085/tcp 依然在列表内，说明这些端口依然是可用的。 想要移除该规则，需要 --remove-port=8082-8085/tcp： 12345$ firewall-cmd --remove-port=8082-8085/tcp --permanentsuccess$ firewall-cmd --reloadsuccess$ firewall-cmd --list-port 这一条防火墙规则算是正确删掉了 参考链接Linux firewall-cmd 命令详解","link":"/2020/08/27/firewall/"},{"title":"windows 下的常见软件提要","text":"虽然我每次装完系统，都会给系统做备份，但这个备份我是从来不用，因为我总是喜欢装最新版本的操作系统，并且也记不清对以前备份的系统做了些什么，然后每次装个新系统老是要想半天这次又要装些什么软件呢？所以这个文章就诞生了，记录一下我对一个纯净的操作系统做了些什么~ 内容可能会根据工作的内容的变化而变化。 Windows10:Latest 可以在 d:/iamges/ 下找到安装镜像，也可以前往 https://msdn.itellyou.cn/ 查看是否有新版本发布。 安装完系统后，首先卸载掉一堆不需要的 Win10 自带应用 鲁大师 ，安装驱动。 如果网络不方便，请前往 d:/soft/1-base/ 安装历史版本 如果网卡不能免驱，请前往 d:/soft/1-base/ 安装驱动精灵万能网卡版 常用软件下述软件如果没有没有提供下载链接，或者下载链接失效，无法访问下载链接，请直接前往 d:/soft/1-base 使用安装包安装。 ShadowSockesR SSTap WinRarX64 Or WinRarX86 IDM BitComet Chrome DISM++ 网易云音乐 QQ 音乐 有道词典 Potplayer PanDownload TIM Office365 MPic 可选软件下述软件如果没有没有提供下载链接，或者下载链接失效，无法访问下载链接，请直接前往 d:/soft/2-option 使用安装包安装。 FireFox 迅雷X MacType G302 Driver Cpu-z Gpu-z Steam OBS 三星固态硬盘管理软件 Foxmail 通用开发工具下述软件如果没有没有提供下载链接，或者下载链接失效，无法访问下载链接，请直接前往 d:/soft/3-common 使用安装包安装。 VMware15 Navicat Putty Redis Desktop Manager 这个下载好像有点麻烦，考虑本地安装包或者换一个？ NotePad++ Git GitKraken PostMan Go下述软件如果没有没有提供下载链接，或者下载链接失效，无法访问下载链接，请直接前往d:/soft/4-go使用安装包安装。 Go SDK Goland 小工具登录 OneDriver，tools 目录下的一些常用小软件： PicGo ScreenToGif WSL访问 Microsoft Store，安装 Ubuntu，在某些场景下有用 清理用 Dism++ 完成个性化设置，并清理文件","link":"/2020/08/27/init-windows/"},{"title":"PicGo 新的图床工具","text":"之前一直使用的图床工具是 MPic，虽然软件长期没有更新，但对我来说，MPic 足够的简单易用，并且是绿色软件，点开即用，使其看起来更加的轻量。 但是最近我发现 MPic 的官网已经打不开了，这意味着其提供的 预览和管理图片 功能无法再使用，因此，我不得不重新寻找一款新的图床工具。 PicGo通过谷歌搜索 图床工具 可以很轻松的找到一系列的图床工具，其中 PicGo 引起了我的注意，这款工具的名称风格让我以为它是使用 Go 语言开发的。 显然我是想太多了，PicGo 是基于 Electron-vue 构建并开源的，不过 PicGo 看起来还是很不错的，它拥有很多的优点，特别是这三点： 支持 Windows, macOS, Linux。 支持 快捷键上传 剪切板里的第一张图片，且快捷键可以根据自己的习惯修改。 上传图片后 自动复制链接 到剪切板，且支持多种风格的链接（html、markdown、自定义风格等）。 基于这三点，PicGo 上传图片的操作异常简单：Ctrl + C（或者截图）-&gt; 上传快捷键 -&gt; Ctrl + V。然后我就可以得到一个 markdown 的图片链接。整个过程是如此的简单而灵活，必需给作者一个赞。 使用方式这里简单记录一下 Windows 平台下，使用 PicGo 作为图床工具，管理七牛云对象的过程。 下载并安装 PicGo前往 https://github.com/Molunerfinn/PicGo/releases 根据自己的平台，选择下载最新的稳定版即可。如果你想尝鲜，也可以选择 Beta 版。 然后双击安装程序，下一步，完成安装即可，没啥好说的。 图床配置显示图床 PicGo 支持多种图床，而我目前只使用七牛云，对于其它用不到的图床，可以在 PicGo 设置界面将其隐藏： 填写图床信息 这些配置项都取决于你自己的实际情况，如果你不清楚相关配置项应该如何填写的话，可以搜索一下入门文章或者七牛云官方文档。 一个坑对于使用七牛云的同学，在设置图床时，访问地址 记得填上 http:// 或者 https://。 虽然不填不会报错，图片也能正确上传，但这会影响到生成的链接和图片预览。 如果去掉访问地址的 https://，此时生成的图片链接会是这样：![name](cdn.sguan.top/makrdown/20200504174627.png)，虽然图片已经上传成功，但这个地址很多 markdown 渲染器是无法正确渲染的，需要我们手动加上 https://。 并且图片预览界面也会异常，无法正常显示这种图片。 总结 MPic 相较于 PicGo 唯一的优点可能就是轻量，无需安装即可使用，其它的我个人觉得 PicGo 完胜。 PicGo 支持插件，且拥有不错的生态，我对其未来充满信心，至少不会轻易跑路，遇到问题也方便寻求帮助（事实上，上面那个坑的解决方法就是在 PicGo 仓库的 issue 中找到的）。 Mac 版的 GUI 比较漂亮，有毛玻璃效果，而 Windows 版就一言难尽了，相比之下比较难看。 PicGo 是一款简洁而强大的图床工具。 参考链接PicGo。 上传图片后就看不到图片了","link":"/2020/08/27/new-image-host/"},{"title":"windows 下端口被占用的问题","text":"在windows平台下启动某个软件，有时候会出现如下错误，提示端口已经被占用。 找到占用端口的程序，并杀掉该程序打开 cmd 命令行，执行： 1$ netstat -aon|findstr \"1080\" 其中 1080 为要想排查的端口号 再输出结果中，其中最后一列表示程序 PID，打开任务管理器，找到 PID 对应的程序关闭即可。 如果任务管理内没有 PID 这一列，可以右键字段列表，勾选 PID 即可 无法找到占用端口的程序有些情况下，通过上面的命令找不到任何占用该端口的程序，但运行软件依然会提示端口已被占用。 此时需要以管理员身份打开命令行，然后运行下面的命令： 1$ netsh winsock reset 随后重启计算机即可 参考链接关于端口被占用而又找不到被占用的程序的解决办法","link":"/2020/08/27/port-used/"},{"title":"SSH 公钥登录以及多证书管理","text":"SSH 公钥登录以及一些问题的笔记 生成密钥对在服务器上生成用于登录的公钥和私钥，最终公钥放于服务器，私钥自己保存使用。 1$ ssh-keygen -t rsa 首先提示输入生成文件的输出路径，然后是密码，最后是确认密码 密码是用于加密和登录时输入的密码，额，建议为空，不然还叫免密登录吗，但是请确保生成证书的安全，证书泄露可能很危险 生产环境强烈建议设置密码，毕竟稳定压倒一切,相当于双重验证吧，需要提供私钥，还要提供密码 导入公钥1$ cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys 配置文件、文件夹的权限123$ sudo chmod -R 0700 ~/.ssh$ sudo chmod -R 0600 ~/.ssh/authorized_keys$ sudo chown -R guan:guan /home/guan # guan 替换为自己的用户名 SELinux如果启用了 SELinux，还需要执行（root 用户把 /home 改成 /root） 1$ restorecon -R -v /home 修改 SSH 配置文件修改 SSH 配置文件，支持使用证书登录，修改该文件需要 root 权限。 找到并修改 /etc/ssh/sshd_config 文件下面的这些配置项： /etc/ssh/sshd_config查看源文件12345RSAAuthentication yes #RSA验证方式StrictModes yes #严格模式，会检查相关目录的权限,根据自己情况选择PubkeyAuthentication yes #允许用户使用自己生成的公私钥AuthorizedKeysFile .ssh/authorized_keys #公钥地址PasswordAuthentication no #是否允许通过密码登录 随后重启 SSH 服务： 1systemctl restart sshd 获取私钥客户端获取私钥，可以使用 scp 或者其它方式： 1$ scp guan@192.168.1.2:~/.ssh/rsa ./ 需要注意的是，在 windows 环境下，不要直接复制粘贴密钥对，这会使其失效。 前面修改了 SSH 配置，并且你恰好禁止的密码登录，此时你可能无法顺利拿到私钥，即： /etc/ssh/sshd_config查看源文件1PasswordAuthentication no #是否允许通过密码登录 你可以先将这一项改为 yes，后续再修改回来。 使用私钥拿到私钥后，不同客户端使用私钥的方式有所不同，不过其原理都是相同的。 PuTTY生成证书可以使用 PuTTY Key Generator 生成适用于 Putty 的证书 选中私钥文件，然后点击保存为私钥 Save private key 使用证书 打开Putty，加载或者新建一个会话 点击 connection-&gt;data , 输入 Auto-login username (自动登录的用户名) connection-&gt;ssh-&gt;auth 在Private key file for authentication选择私钥文件 保存会话，然后直接点击会话即可免密登录 sh对于各种 shell 环境，直接将私钥复制到 ~/.ssh/ 下，命名为 id_rsa 即可。 1$ cp id_rsa ~/.ssh/id_rsa 然后便可以直接进行 ssh 登录： 1$ ssh guan@192.168.1.2 公钥部署到多个服务器再提醒一下，客户端使用私钥，服务端使用公钥。 将一份公钥部署到多个服务器，并正确配置，可以使用实现一份私钥免密登录到多个服务器上。当然这相当于将鸡蛋都装到了一个篮子里，安全风险也更大一些。 我们可以直接在多个服务器之间使用 scp 传输公钥： 1ssh user@host 'mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys' &lt; ~/.ssh/id_rsa.pub 需要注意的是，不要直接复制粘贴公钥，很可能出错，导致服务器拒绝登录，特别是 windows 环境下 SSH 登录慢的问题原因OpenSSH 在用户登录的时候会验证 IP，它根据用户的 IP 使用反向 DNS 找到主机名，再使用 DNS 找到 IP 地址，最后匹配一下登录的 IP 是否合法。如果客户机的 IP 没有域名，或者 DNS 服务器很慢或不通，会一直等到DNS超时，SSH 登录慢就体现在这里。 解决方法修改 ssh 的配置文件，关闭 DNS 和 GSSAPI 验证即可加快登陆速度。 编辑 OpenSSH 的主配置文件 /etc/ssh/sshd_config，找到并修改下面两个配置项 /etc/ssh/sshd_config12GSSAPIAuthentication noUseDNS no 然后重启 SSH 服务，再尝试登录测试一下是否有效。 1$ systemctl restart sshd 再尝试登录测试一下是否有效。 多证书管理前面说到了通过证书进行 SSH 免密登录，但在管理多个私钥的时候又有了新的问题。 在只有一份密钥对的时候，将公钥放在服务器上，并配置好 SSH，客户端将私钥保存为 ~/.ssh/id_rsa 即可进行免密登录，这个过程叫做 公钥登录。例如： 1$ ssh root@192.168.1.1 但是，当拥有多个密钥对时，如何使用呢？ 实际上，我们可以通过 -i 参数，指定要使用的私钥，这样就可以使用多个私钥了。例如： 1$ ssh -i ~/.ssh/id_local root@192.168.1.1 -i：identity_file，该参数指定要使用的证书。 之所以前面我们不指定该参数，也可以进行免密登录，是因为 ssh 默认会尝试并使用 ~/.ssh 目录下的几个证书（id_ecdsa、id_ed25519、id_rsa 等），如果存在且可用的话则使用，否则会提示输入密码。 config虽然我们可以通过 -i 指定私钥，但随着数量增多，还是存在一些不便。此时我们可以通过配置 config 文件，来为不同主机配置不同的私钥，而无需每次都指定。 此外，还可以为主机配置别名，免去记不住 IP 地址的烦恼： ~/.ssh/config12345678910Host host1HostName 192.168.7.11User rootPort 22IdentityFile ~/.ssh/id_rsaHost host2HostName 192.168.7.12User rootPort 22 Host 相当于别名，可以通过该值替代 HostName IdentityFile 不是必须的，不指定则相当于口令方式登录。 参考链接CentOS 7 SSH使用证书登录 Putty server refused our key的三种原因和解决方法 SSH原理与运用（一）：远程登录 使用 SSH config 文件","link":"/2020/08/27/ssh-auth/"},{"title":"Git 的一些使用技巧","text":"不是 Git 的基本操作，更像是一些技巧、应用，网上找的，做一下记录。 .gitignore 忽略.idea无效的问题参考连接 idea git无法忽略.idea,target文件夹及.iml文件 git 项目代码贡献统计1git log --format='%aN' | sort -u | while read name; do echo -en \"$name\\t\"; git log --author=\"$name\" --pretty=tformat: --numstat | awk '{ add += $1; subs += $2; loc += $1 - $2 } END { printf \"added lines: %s, removed lines: %s, total lines: %s\\n\", add, subs, loc }' -; done 项目代码总行数1find . \"(\" -name \"*.go\" \")\" -print | xargs wc -l 其中 .go 表示要统计的文件后缀，可以根据自己的情况修改 批量删除分支删除当前分支外的所有分支： 1git branch | xargs git branch -d 删除分支名包含指定字符的分支（当然，当前分支还是例外）： 1git branch | grep ‘zh-trans-*’ | xargs git branch -d 参考链接Git批量删除本地分支","link":"/2020/08/27/git/"},{"title":"一条命令实现 Windows 下的“open”命令","text":"在 MacOS 和带 GUI 的 Linux 下使用命令行时，可以通过 open 命令方便快捷的打开当前目录，在 Windows 下怎么实现呢？ 命令执行如下命令： 1$ echo \"alias open='explorer.exe'\"&gt;&gt; ~/.bashrc &amp;&amp; source ~/.bashrc 随后执行命令查看是否有效： 1$ open . explorer在 Windows 下，图形界面的文件系统使用的是一个叫做 exploere.exe 的程序，我们看到的桌面图标、任务栏、我的电脑等都是由该程序提供的支持。 该程序也支持命令行调用，我们直接调用该程序，会打开资源管理器，例如： 1$ explorer 如果带上参数 .，则相会打开当前路径： 1$ explorer . 此外，还支持带上绝对、相对路径： 12$ explorer \"C:\\Users\"$ explorer \"Codes\" 注意路径必须用引号包裹住 实现原理本文就是为 explorer 增加了一个别名，实现了类似 MacOS 下 open 的功能。当然你也可以不使用别名，直接使用 explorer，只是拼写会麻烦一点。 另外，explorer 打开绝对路径不支持 &quot;/d/some/codes/ab&quot; 这种风格，必须是 &quot;D:\\some\\codes\\ab&quot;，个人觉得不太方便。不过对于 open .，这已经足够了。 explorer 的更多语法可以查看下面的参考链接。 参考链接Explorer.exe","link":"/2020/09/02/command-open-in-windows/"},{"title":"SSH 加密及连接过程","text":"公钥登录是连接服务器的一种常见操作，在此记录一下我的看法 概述SSH 登录过程我认为应该分为两步：连接与验证，很多文章在介绍原理时，忽略了连接步骤，只讲了验证这一步，不知道这是否有必要，总是我还是写写吧，加深理解。 连接SSH，全称 Secure Shell，是一种加密的网络传输协议，可在不安全网络中为网络服务提供安全的传输环境。 安装有 SSH 的服务端，会有一份默认的密钥对，当有客户端尝试进行 SSH 登录时，服务端会将公钥下发给客户端。对于首次连接的服务端，会提示一个我们经常看到的内容： 1234$ ssh root@192.168.7.11The authenticity of host '192.168.7.11 (192.168.7.11)' can't be established.ECDSA key fingerprint is SHA256:qjwNOQ46uFsG6kDScW1JfkVzt6ms4FMPFPNRkMtNoLY.Are you sure you want to continue connecting (yes/no/[fingerprint])? 大意是：这个未知的主机不一定可信，它的指纹是 SHA256:qjwNOQ46uFsG6kDScW1JfkVzt6ms4FMPFPNRkMtNoLY，你想要继续建立连接吗？此时我们一般会输入 yes 继续连接。 随后，并不是客户端使用公钥将密码加密码传输给服务端进行验证，而是需要先连接，大致步骤如下： 通信双方协商一个 质数1 作为种子，一种加密方式后续会用到 通信双方再各自生成一个 质数，该质数作为对方的私钥，可以叫做 Server-私钥 和 Client-私钥，不告知对方。 服务端使用 Server-私钥、质数1根据加密方式生成Server-公钥；客户端类似的，生成Client-公钥 通信双方交换公钥。 服务端使用 Server-私钥、Client-公钥根据加密方式生成通信密钥，客户端使用 Client-私钥、Server-公钥根据加密方式生成通信密钥。此时 通信密钥1 必然与 通信密钥2 完全相同，相关证明可以查看迪菲-赫尔曼密钥交换 使用通信密钥进行加密通信。 验证口令登录和公钥登录只是两种不同的身份验证方式，它们都需要建立在加密连接的基础之上，传输的数据均通过通信密钥加密。能不能连接是一码事，能不能通过身份验证又是另一码事。 口令登录此时的过程大致如下： 客户端通过 公钥加密(密码) 将密码加密传输给服务端 服务端通过 私钥解密(密码) 获取到密码 密码验证通过则允许登录 公钥登录此时的过程大致如下： 客户端将密钥对ID发送给服务端 服务端检查是否有匹配密钥对ID的公钥（这些公钥一般保存在 ~/.ssh/authorized_keys 下） 如果找到，则使用该公钥对随机数1 进行加密，并将加密后的内容发送给客户端 客户端收到加密内容，使用自己的私钥进行解密，得到随机数1。 客户端将连接过程中生成的通信密钥和随机数1结合，计算其 MD5，并将结果发送给服务端。 服务端使用相同方式计算 MD5，对比客户端传回的 MD5，如果匹配，则通过验证，允许登录，不要求密码 小结连接过程与 TLS 连接类似，事实上目前互联网所有涉及加密的通信原理都类似，基本都离不开 PKI 体系 保存一份公钥，意味着你信任对应的私钥方，有时候你从某网站拿到的公钥并不是真正的公钥，可能已经被中间人替换掉，但证书指纹是无法伪造的，因此有些网站会将自己公钥证书的指纹公示在显眼的位置，以便使用者对比指纹，判断自己得到的公钥是否被替换过。总之，面对来历不明的公钥，我们需要多加注意。 密钥对一般包含公钥和私钥，公钥可以广泛传播，而私钥则需要小心保存。 公钥、私钥都可以进行加解密，但这容易产生误解，因此我们一般将公钥加密，私钥解密称为加密和解密，将私钥加密，公钥解密称为签名和验证签名。加密是为了数据安全，签名是为了向对方证明身份（我真的是私钥拥有者鸭）。 本文验证过程与很多文章不同，主要参考了 Understanding the SSH Encryption and Connection Process ，如有不对的地方，欢迎批评指正。 参考链接Understanding the SSH Encryption and Connection Process","link":"/2020/09/02/encryption-and-connection-process/"},{"title":"如何在 Webhook 数据中区分 issue 和 pr","text":"GitHub 的 issue 和 pull request 是两个不同的对象，但实际上，在一个仓库中，这两个对象的 ID 是不重复的，也就是说 issue 和 request 共享一类 ID。 共享一类 ID在访问 GitHub 的时候，issue 的地址一般类似于这样： 1https://github.com/1kib/new/issue/1380 pull request 的地址一般是这样： 1https://github.com/1kib/new/pull/1381 我们其实可以将上面两个连接中的 issue 和 pull 字符互换，而不影响页面的访问，GitHub 会自动重定向，因为 ID 是不重复的。 Webhook由于它们的 ID 未作区分，创建 Webhook 后，在处理 comment payload 时，可能会导致错误，因为 issue comment 和 pr comment 公用的同一个 payload，数据内容相似度非常高。 例如： issue_comment_payload.json >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187{ \"action\":\"created\", \"issue\":{ \"url\":\"https://api.github.com/repos/1kib/new/issues/1380\", \"labels_url\":\"https://api.github.com/repos/1kib/new/issues/1380/labels{/name}\", \"comments_url\":\"https://api.github.com/repos/1kib/new/issues/1380/comments\", \"events_url\":\"https://api.github.com/repos/1kib/new/issues/1380/events\", \"html_url\":\"https://github.com/1kib/new/issues/1380\", \"id\":689722355, \"node_id\":\"MDU6SXNzdWU2ODk3MjIzNTU=\", \"number\":1380, \"title\":\"Test Issue\", \"user\":{ \"login\":\"3ks\", \"id\":32058002, \"node_id\":\"MDQ6VXNlcjMyMDU4MDAy\", \"avatar_url\":\"https://avatars3.githubusercontent.com/u/32058002?v=4\", \"gravatar_id\":\"\", \"url\":\"https://api.github.com/users/3ks\", \"html_url\":\"https://github.com/3ks\", \"followers_url\":\"https://api.github.com/users/3ks/followers\", \"following_url\":\"https://api.github.com/users/3ks/following{/other_user}\", \"gists_url\":\"https://api.github.com/users/3ks/gists{/gist_id}\", \"starred_url\":\"https://api.github.com/users/3ks/starred{/owner}{/repo}\", \"subscriptions_url\":\"https://api.github.com/users/3ks/subscriptions\", \"organizations_url\":\"https://api.github.com/users/3ks/orgs\", \"repos_url\":\"https://api.github.com/users/3ks/repos\", \"events_url\":\"https://api.github.com/users/3ks/events{/privacy}\", \"received_events_url\":\"https://api.github.com/users/3ks/received_events\", \"type\":\"User\", \"site_admin\":false }, \"labels\":[ ], \"state\":\"open\", \"locked\":false, \"assignee\":null, \"assignees\":[ ], \"milestone\":null, \"comments\":2, \"created_at\":\"2020-09-01T00:58:56Z\", \"updated_at\":\"2020-09-01T01:13:01Z\", \"closed_at\":null, \"body\":\"123\" }, \"comment\":{ \"url\":\"https://api.github.com/repos/1kib/new/issues/comments/684132075\", \"html_url\":\"https://github.com/1kib/new/issues/1380#issuecomment-684132075\", \"issue_url\":\"https://api.github.com/repos/1kib/new/issues/1380\", \"id\":684132075, \"node_id\":\"MDEyOklzc3VlQ29tbWVudDY4NDEzMjA3NQ==\", \"user\":{ \"login\":\"3ks\", \"id\":32058002, \"node_id\":\"MDQ6VXNlcjMyMDU4MDAy\", \"avatar_url\":\"https://avatars3.githubusercontent.com/u/32058002?v=4\", \"gravatar_id\":\"\", \"url\":\"https://api.github.com/users/3ks\", \"html_url\":\"https://github.com/3ks\", \"followers_url\":\"https://api.github.com/users/3ks/followers\", \"following_url\":\"https://api.github.com/users/3ks/following{/other_user}\", \"gists_url\":\"https://api.github.com/users/3ks/gists{/gist_id}\", \"starred_url\":\"https://api.github.com/users/3ks/starred{/owner}{/repo}\", \"subscriptions_url\":\"https://api.github.com/users/3ks/subscriptions\", \"organizations_url\":\"https://api.github.com/users/3ks/orgs\", \"repos_url\":\"https://api.github.com/users/3ks/repos\", \"events_url\":\"https://api.github.com/users/3ks/events{/privacy}\", \"received_events_url\":\"https://api.github.com/users/3ks/received_events\", \"type\":\"User\", \"site_admin\":false }, \"created_at\":\"2020-09-01T01:13:01Z\", \"updated_at\":\"2020-09-01T01:13:01Z\", \"body\":\"111\", \"author_association\":\"CONTRIBUTOR\" }, \"repository\":{ \"id\":269285897, \"node_id\":\"MDEwOlJlcG9zaXRvcnkyNjkyODU4OTc=\", \"name\":\"new\", \"full_name\":\"1kib/new\", \"owner\":{ \"login\":\"1kib\", \"id\":66345678, \"node_id\":\"MDEyOk9yZ2FuaXphdGlvbjY2MzQ1Njc4\", \"avatar_url\":\"https://avatars3.githubusercontent.com/u/66345678?v=4\", \"gravatar_id\":\"\", \"url\":\"https://api.github.com/users/1kib\", \"html_url\":\"https://github.com/1kib\", \"followers_url\":\"https://api.github.com/users/1kib/followers\", \"following_url\":\"https://api.github.com/users/1kib/following{/other_user}\", \"gists_url\":\"https://api.github.com/users/1kib/gists{/gist_id}\", \"starred_url\":\"https://api.github.com/users/1kib/starred{/owner}{/repo}\", \"subscriptions_url\":\"https://api.github.com/users/1kib/subscriptions\", \"organizations_url\":\"https://api.github.com/users/1kib/orgs\", \"repos_url\":\"https://api.github.com/users/1kib/repos\", \"events_url\":\"https://api.github.com/users/1kib/events{/privacy}\", \"received_events_url\":\"https://api.github.com/users/1kib/received_events\", \"type\":\"Organization\", \"site_admin\":false }, \"private\":false, \"html_url\":\"https://github.com/1kib/new\", \"description\":\"一个工具人仓库\", \"fork\":false, \"url\":\"https://api.github.com/repos/1kib/new\", \"forks_url\":\"https://api.github.com/repos/1kib/new/forks\", \"keys_url\":\"https://api.github.com/repos/1kib/new/keys{/key_id}\", \"collaborators_url\":\"https://api.github.com/repos/1kib/new/collaborators{/collaborator}\", \"teams_url\":\"https://api.github.com/repos/1kib/new/teams\", \"hooks_url\":\"https://api.github.com/repos/1kib/new/hooks\", \"issue_events_url\":\"https://api.github.com/repos/1kib/new/issues/events{/number}\", \"events_url\":\"https://api.github.com/repos/1kib/new/events\", \"assignees_url\":\"https://api.github.com/repos/1kib/new/assignees{/user}\", \"branches_url\":\"https://api.github.com/repos/1kib/new/branches{/branch}\", \"tags_url\":\"https://api.github.com/repos/1kib/new/tags\", \"blobs_url\":\"https://api.github.com/repos/1kib/new/git/blobs{/sha}\", \"git_tags_url\":\"https://api.github.com/repos/1kib/new/git/tags{/sha}\", \"git_refs_url\":\"https://api.github.com/repos/1kib/new/git/refs{/sha}\", \"trees_url\":\"https://api.github.com/repos/1kib/new/git/trees{/sha}\", \"statuses_url\":\"https://api.github.com/repos/1kib/new/statuses/{sha}\", \"languages_url\":\"https://api.github.com/repos/1kib/new/languages\", \"stargazers_url\":\"https://api.github.com/repos/1kib/new/stargazers\", \"contributors_url\":\"https://api.github.com/repos/1kib/new/contributors\", \"subscribers_url\":\"https://api.github.com/repos/1kib/new/subscribers\", \"subscription_url\":\"https://api.github.com/repos/1kib/new/subscription\", \"commits_url\":\"https://api.github.com/repos/1kib/new/commits{/sha}\", \"git_commits_url\":\"https://api.github.com/repos/1kib/new/git/commits{/sha}\", \"comments_url\":\"https://api.github.com/repos/1kib/new/comments{/number}\", \"issue_comment_url\":\"https://api.github.com/repos/1kib/new/issues/comments{/number}\", \"contents_url\":\"https://api.github.com/repos/1kib/new/contents/{+path}\", \"compare_url\":\"https://api.github.com/repos/1kib/new/compare/{base}...{head}\", \"merges_url\":\"https://api.github.com/repos/1kib/new/merges\", \"archive_url\":\"https://api.github.com/repos/1kib/new/{archive_format}{/ref}\", \"downloads_url\":\"https://api.github.com/repos/1kib/new/downloads\", \"issues_url\":\"https://api.github.com/repos/1kib/new/issues{/number}\", \"pulls_url\":\"https://api.github.com/repos/1kib/new/pulls{/number}\", \"milestones_url\":\"https://api.github.com/repos/1kib/new/milestones{/number}\", \"notifications_url\":\"https://api.github.com/repos/1kib/new/notifications{?since,all,participating}\", \"labels_url\":\"https://api.github.com/repos/1kib/new/labels{/name}\", \"releases_url\":\"https://api.github.com/repos/1kib/new/releases{/id}\", \"created_at\":\"2020-06-04T07:08:05Z\", \"updated_at\":\"2020-06-19T01:05:05Z\", \"pushed_at\":\"2020-06-19T01:05:03Z\", \"git_url\":\"git://github.com/1kib/new.git\", \"ssh_url\":\"git@github.com:1kib/new.git\", \"clone_url\":\"https://github.com/1kib/new.git\", \"svn_url\":\"https://github.com/1kib/new\", \"homepage\":null, \"size\":9, \"stargazers_count\":0, \"watchers_count\":0, \"language\":null, \"has_issues\":true, \"has_downloads\":true, \"has_wiki\":true, \"has_pages\":false, \"forks_count\":1, \"mirror_url\":null, \"open_issues_count\":358, \"forks\":1, \"open_issues\":358, \"watchers\":0, \"default_branch\":\"master\" }, \"sender\":{ \"login\":\"3ks\", \"id\":32058002, \"node_id\":\"MDQ6VXNlcjMyMDU4MDAy\", \"avatar_url\":\"https://avatars3.githubusercontent.com/u/32058002?v=4\", \"gravatar_id\":\"\", \"url\":\"https://api.github.com/users/3ks\", \"html_url\":\"https://github.com/3ks\", \"followers_url\":\"https://api.github.com/users/3ks/followers\", \"following_url\":\"https://api.github.com/users/3ks/following{/other_user}\", \"gists_url\":\"https://api.github.com/users/3ks/gists{/gist_id}\", \"starred_url\":\"https://api.github.com/users/3ks/starred{/owner}{/repo}\", \"subscriptions_url\":\"https://api.github.com/users/3ks/subscriptions\", \"organizations_url\":\"https://api.github.com/users/3ks/orgs\", \"repos_url\":\"https://api.github.com/users/3ks/repos\", \"events_url\":\"https://api.github.com/users/3ks/events{/privacy}\", \"received_events_url\":\"https://api.github.com/users/3ks/received_events\", \"type\":\"User\", \"site_admin\":false }} 和： pull_request_comment_payload.json >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187{ \"action\":\"created\", \"issue\":{ \"url\":\"https://api.github.com/repos/1kib/new/issues/1381\", \"labels_url\":\"https://api.github.com/repos/1kib/new/issues/1381/labels{/name}\", \"comments_url\":\"https://api.github.com/repos/1kib/new/issues/1381/comments\", \"events_url\":\"https://api.github.com/repos/1kib/new/issues/1381/events\", \"html_url\":\"https://github.com/1kib/new/pull/1381\", \"id\":689730941, \"node_id\":\"MDExOlB1bGxSZXF1ZXN0NDc2NzQ3MjU0\", \"number\":1381, \"title\":\"PR test\", \"user\":{ \"login\":\"3ks\", \"id\":32058002, \"node_id\":\"MDQ6VXNlcjMyMDU4MDAy\", \"avatar_url\":\"https://avatars3.githubusercontent.com/u/32058002?v=4\", \"gravatar_id\":\"\", \"url\":\"https://api.github.com/users/3ks\", \"html_url\":\"https://github.com/3ks\", \"followers_url\":\"https://api.github.com/users/3ks/followers\", \"following_url\":\"https://api.github.com/users/3ks/following{/other_user}\", \"gists_url\":\"https://api.github.com/users/3ks/gists{/gist_id}\", \"starred_url\":\"https://api.github.com/users/3ks/starred{/owner}{/repo}\", \"subscriptions_url\":\"https://api.github.com/users/3ks/subscriptions\", \"organizations_url\":\"https://api.github.com/users/3ks/orgs\", \"repos_url\":\"https://api.github.com/users/3ks/repos\", \"events_url\":\"https://api.github.com/users/3ks/events{/privacy}\", \"received_events_url\":\"https://api.github.com/users/3ks/received_events\", \"type\":\"User\", \"site_admin\":false }, \"labels\":[ ], \"state\":\"open\", \"locked\":false, \"assignee\":null, \"assignees\":[ ], \"milestone\":null, \"comments\":2, \"created_at\":\"2020-09-01T01:21:22Z\", \"updated_at\":\"2020-09-01T01:34:48Z\", \"closed_at\":null, \"body\":\"Test\" }, \"comment\":{ \"url\":\"https://api.github.com/repos/1kib/new/issues/comments/684138714\", \"html_url\":\"https://github.com/1kib/new/pull/1381#issuecomment-684138714\", \"issue_url\":\"https://api.github.com/repos/1kib/new/issues/1381\", \"id\":684138714, \"node_id\":\"MDEyOklzc3VlQ29tbWVudDY4NDEzODcxNA==\", \"user\":{ \"login\":\"3ks\", \"id\":32058002, \"node_id\":\"MDQ6VXNlcjMyMDU4MDAy\", \"avatar_url\":\"https://avatars3.githubusercontent.com/u/32058002?v=4\", \"gravatar_id\":\"\", \"url\":\"https://api.github.com/users/3ks\", \"html_url\":\"https://github.com/3ks\", \"followers_url\":\"https://api.github.com/users/3ks/followers\", \"following_url\":\"https://api.github.com/users/3ks/following{/other_user}\", \"gists_url\":\"https://api.github.com/users/3ks/gists{/gist_id}\", \"starred_url\":\"https://api.github.com/users/3ks/starred{/owner}{/repo}\", \"subscriptions_url\":\"https://api.github.com/users/3ks/subscriptions\", \"organizations_url\":\"https://api.github.com/users/3ks/orgs\", \"repos_url\":\"https://api.github.com/users/3ks/repos\", \"events_url\":\"https://api.github.com/users/3ks/events{/privacy}\", \"received_events_url\":\"https://api.github.com/users/3ks/received_events\", \"type\":\"User\", \"site_admin\":false }, \"created_at\":\"2020-09-01T01:34:47Z\", \"updated_at\":\"2020-09-01T01:34:47Z\", \"body\":\"11111\", \"author_association\":\"CONTRIBUTOR\" }, \"repository\":{ \"id\":269285897, \"node_id\":\"MDEwOlJlcG9zaXRvcnkyNjkyODU4OTc=\", \"name\":\"new\", \"full_name\":\"1kib/new\", \"owner\":{ \"login\":\"1kib\", \"id\":66345678, \"node_id\":\"MDEyOk9yZ2FuaXphdGlvbjY2MzQ1Njc4\", \"avatar_url\":\"https://avatars3.githubusercontent.com/u/66345678?v=4\", \"gravatar_id\":\"\", \"url\":\"https://api.github.com/users/1kib\", \"html_url\":\"https://github.com/1kib\", \"followers_url\":\"https://api.github.com/users/1kib/followers\", \"following_url\":\"https://api.github.com/users/1kib/following{/other_user}\", \"gists_url\":\"https://api.github.com/users/1kib/gists{/gist_id}\", \"starred_url\":\"https://api.github.com/users/1kib/starred{/owner}{/repo}\", \"subscriptions_url\":\"https://api.github.com/users/1kib/subscriptions\", \"organizations_url\":\"https://api.github.com/users/1kib/orgs\", \"repos_url\":\"https://api.github.com/users/1kib/repos\", \"events_url\":\"https://api.github.com/users/1kib/events{/privacy}\", \"received_events_url\":\"https://api.github.com/users/1kib/received_events\", \"type\":\"Organization\", \"site_admin\":false }, \"private\":false, \"html_url\":\"https://github.com/1kib/new\", \"description\":\"一个工具人仓库\", \"fork\":false, \"url\":\"https://api.github.com/repos/1kib/new\", \"forks_url\":\"https://api.github.com/repos/1kib/new/forks\", \"keys_url\":\"https://api.github.com/repos/1kib/new/keys{/key_id}\", \"collaborators_url\":\"https://api.github.com/repos/1kib/new/collaborators{/collaborator}\", \"teams_url\":\"https://api.github.com/repos/1kib/new/teams\", \"hooks_url\":\"https://api.github.com/repos/1kib/new/hooks\", \"issue_events_url\":\"https://api.github.com/repos/1kib/new/issues/events{/number}\", \"events_url\":\"https://api.github.com/repos/1kib/new/events\", \"assignees_url\":\"https://api.github.com/repos/1kib/new/assignees{/user}\", \"branches_url\":\"https://api.github.com/repos/1kib/new/branches{/branch}\", \"tags_url\":\"https://api.github.com/repos/1kib/new/tags\", \"blobs_url\":\"https://api.github.com/repos/1kib/new/git/blobs{/sha}\", \"git_tags_url\":\"https://api.github.com/repos/1kib/new/git/tags{/sha}\", \"git_refs_url\":\"https://api.github.com/repos/1kib/new/git/refs{/sha}\", \"trees_url\":\"https://api.github.com/repos/1kib/new/git/trees{/sha}\", \"statuses_url\":\"https://api.github.com/repos/1kib/new/statuses/{sha}\", \"languages_url\":\"https://api.github.com/repos/1kib/new/languages\", \"stargazers_url\":\"https://api.github.com/repos/1kib/new/stargazers\", \"contributors_url\":\"https://api.github.com/repos/1kib/new/contributors\", \"subscribers_url\":\"https://api.github.com/repos/1kib/new/subscribers\", \"subscription_url\":\"https://api.github.com/repos/1kib/new/subscription\", \"commits_url\":\"https://api.github.com/repos/1kib/new/commits{/sha}\", \"git_commits_url\":\"https://api.github.com/repos/1kib/new/git/commits{/sha}\", \"comments_url\":\"https://api.github.com/repos/1kib/new/comments{/number}\", \"issue_comment_url\":\"https://api.github.com/repos/1kib/new/issues/comments{/number}\", \"contents_url\":\"https://api.github.com/repos/1kib/new/contents/{+path}\", \"compare_url\":\"https://api.github.com/repos/1kib/new/compare/{base}...{head}\", \"merges_url\":\"https://api.github.com/repos/1kib/new/merges\", \"archive_url\":\"https://api.github.com/repos/1kib/new/{archive_format}{/ref}\", \"downloads_url\":\"https://api.github.com/repos/1kib/new/downloads\", \"issues_url\":\"https://api.github.com/repos/1kib/new/issues{/number}\", \"pulls_url\":\"https://api.github.com/repos/1kib/new/pulls{/number}\", \"milestones_url\":\"https://api.github.com/repos/1kib/new/milestones{/number}\", \"notifications_url\":\"https://api.github.com/repos/1kib/new/notifications{?since,all,participating}\", \"labels_url\":\"https://api.github.com/repos/1kib/new/labels{/name}\", \"releases_url\":\"https://api.github.com/repos/1kib/new/releases{/id}\", \"created_at\":\"2020-06-04T07:08:05Z\", \"updated_at\":\"2020-06-19T01:05:05Z\", \"pushed_at\":\"2020-09-01T01:21:22Z\", \"git_url\":\"git://github.com/1kib/new.git\", \"ssh_url\":\"git@github.com:1kib/new.git\", \"clone_url\":\"https://github.com/1kib/new.git\", \"svn_url\":\"https://github.com/1kib/new\", \"homepage\":null, \"size\":9, \"stargazers_count\":0, \"watchers_count\":0, \"language\":null, \"has_issues\":true, \"has_downloads\":true, \"has_wiki\":true, \"has_pages\":false, \"forks_count\":1, \"mirror_url\":null, \"open_issues_count\":359, \"forks\":1, \"open_issues\":359, \"watchers\":0, \"default_branch\":\"master\" }, \"sender\":{ \"login\":\"3ks\", \"id\":32058002, \"node_id\":\"MDQ6VXNlcjMyMDU4MDAy\", \"avatar_url\":\"https://avatars3.githubusercontent.com/u/32058002?v=4\", \"gravatar_id\":\"\", \"url\":\"https://api.github.com/users/3ks\", \"html_url\":\"https://github.com/3ks\", \"followers_url\":\"https://api.github.com/users/3ks/followers\", \"following_url\":\"https://api.github.com/users/3ks/following{/other_user}\", \"gists_url\":\"https://api.github.com/users/3ks/gists{/gist_id}\", \"starred_url\":\"https://api.github.com/users/3ks/starred{/owner}{/repo}\", \"subscriptions_url\":\"https://api.github.com/users/3ks/subscriptions\", \"organizations_url\":\"https://api.github.com/users/3ks/orgs\", \"repos_url\":\"https://api.github.com/users/3ks/repos\", \"events_url\":\"https://api.github.com/users/3ks/events{/privacy}\", \"received_events_url\":\"https://api.github.com/users/3ks/received_events\", \"type\":\"User\", \"site_admin\":false }} 通过对比工具对比两者的内容，发现只能通过 payload 中的 URL 来区分两者。 可用的参数有：issue.url 和 issue.html_url（ pr comment 也是这个参数），两者都是一个 URL 链接，包含关键字 issues 则表示 issue 的 comment，包含关键字 pull 则表示 pr 的 comment","link":"/2020/09/01/distinguish-between-issue-and-pr/"}],"tags":[{"name":"GitHub","slug":"GitHub","link":"/tags/GitHub/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"CentOS","slug":"CentOS","link":"/tags/CentOS/"},{"name":"cache","slug":"cache","link":"/tags/cache/"},{"name":"swap","slug":"swap","link":"/tags/swap/"},{"name":"Badge","slug":"Badge","link":"/tags/Badge/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"icarus","slug":"icarus","link":"/tags/icarus/"},{"name":"CDN","slug":"CDN","link":"/tags/CDN/"},{"name":"GitHub Page","slug":"GitHub-Page","link":"/tags/GitHub-Page/"},{"name":"GitHub Action","slug":"GitHub-Action","link":"/tags/GitHub-Action/"},{"name":"go","slug":"go","link":"/tags/go/"},{"name":"todo","slug":"todo","link":"/tags/todo/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"mysql 8.0","slug":"mysql-8-0","link":"/tags/mysql-8-0/"},{"name":"NetworkManager","slug":"NetworkManager","link":"/tags/NetworkManager/"},{"name":"NM","slug":"NM","link":"/tags/NM/"},{"name":"command","slug":"command","link":"/tags/command/"},{"name":"alias","slug":"alias","link":"/tags/alias/"},{"name":"argot","slug":"argot","link":"/tags/argot/"},{"name":"黑话","slug":"黑话","link":"/tags/%E9%BB%91%E8%AF%9D/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"docker-compose","slug":"docker-compose","link":"/tags/docker-compose/"},{"name":"security","slug":"security","link":"/tags/security/"},{"name":"fork bomb","slug":"fork-bomb","link":"/tags/fork-bomb/"},{"name":"centos8","slug":"centos8","link":"/tags/centos8/"},{"name":"draft","slug":"draft","link":"/tags/draft/"},{"name":"windows","slug":"windows","link":"/tags/windows/"},{"name":"PicGo","slug":"PicGo","link":"/tags/PicGo/"},{"name":"port","slug":"port","link":"/tags/port/"},{"name":"ssh","slug":"ssh","link":"/tags/ssh/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"open","slug":"open","link":"/tags/open/"},{"name":"encryption","slug":"encryption","link":"/tags/encryption/"},{"name":"Github","slug":"Github","link":"/tags/Github/"},{"name":"Webhook","slug":"Webhook","link":"/tags/Webhook/"},{"name":"Issue","slug":"Issue","link":"/tags/Issue/"},{"name":"Pull Request","slug":"Pull-Request","link":"/tags/Pull-Request/"}],"categories":[{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"Github","slug":"Github","link":"/categories/Github/"},{"name":"CentOS","slug":"Linux/CentOS","link":"/categories/Linux/CentOS/"},{"name":"blog","slug":"blog","link":"/categories/blog/"},{"name":"go","slug":"go","link":"/categories/go/"},{"name":"todo","slug":"todo","link":"/categories/todo/"},{"name":"database","slug":"database","link":"/categories/database/"},{"name":"Badge","slug":"Github/Badge","link":"/categories/Github/Badge/"},{"name":"network","slug":"network","link":"/categories/network/"},{"name":"command","slug":"command","link":"/categories/command/"},{"name":"argot","slug":"argot","link":"/categories/argot/"},{"name":"cache","slug":"Linux/CentOS/cache","link":"/categories/Linux/CentOS/cache/"},{"name":"docker","slug":"docker","link":"/categories/docker/"},{"name":"security","slug":"security","link":"/categories/security/"},{"name":"hexo","slug":"blog/hexo","link":"/categories/blog/hexo/"},{"name":"the-way-to-go","slug":"go/the-way-to-go","link":"/categories/go/the-way-to-go/"},{"name":"draft","slug":"draft","link":"/categories/draft/"},{"name":"swap","slug":"Linux/CentOS/swap","link":"/categories/Linux/CentOS/swap/"},{"name":"windows","slug":"windows","link":"/categories/windows/"},{"name":"mysql","slug":"database/mysql","link":"/categories/database/mysql/"},{"name":"NetworkManager","slug":"network/NetworkManager","link":"/categories/network/NetworkManager/"},{"name":"alias","slug":"command/alias","link":"/categories/command/alias/"},{"name":"docker-compose","slug":"docker/docker-compose","link":"/categories/docker/docker-compose/"},{"name":"icarus","slug":"blog/hexo/icarus","link":"/categories/blog/hexo/icarus/"},{"name":"install","slug":"windows/install","link":"/categories/windows/install/"},{"name":"PicGo","slug":"PicGo","link":"/categories/PicGo/"},{"name":"ssh","slug":"ssh","link":"/categories/ssh/"},{"name":"git","slug":"git","link":"/categories/git/"},{"name":"command","slug":"windows/command","link":"/categories/windows/command/"},{"name":"Webhook","slug":"Github/Webhook","link":"/categories/Github/Webhook/"}]}